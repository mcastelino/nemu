#!/bin/sh
#
# qemu configure script (c) 2003 Fabrice Bellard
#

# Unset some variables known to interfere with behavior of common tools,
# just as autoconf does.
CLICOLOR_FORCE= GREP_OPTIONS=
unset CLICOLOR_FORCE GREP_OPTIONS

# Don't allow CCACHE, if present, to use cached results of compile tests!
export CCACHE_RECACHE=yes

# Temporary directory used for files created while
# configure runs. Since it is in the build directory
# we can safely blow away any previous version of it
# (and we need not jump through hoops to try to delete
# it when configure exits.)
TMPDIR1="config-temp"
rm -rf "${TMPDIR1}"
mkdir -p "${TMPDIR1}"
if [ $? -ne 0 ]; then
    echo "ERROR: failed to create temporary directory"
    exit 1
fi

TMPB="qemu-conf"
TMPC="${TMPDIR1}/${TMPB}.c"
TMPO="${TMPDIR1}/${TMPB}.o"
TMPCXX="${TMPDIR1}/${TMPB}.cxx"
TMPE="${TMPDIR1}/${TMPB}.exe"
TMPMO="${TMPDIR1}/${TMPB}.mo"

rm -f config.log

# Print a helpful header at the top of config.log
echo "# QEMU configure log $(date)" >> config.log
printf "# Configured with:" >> config.log
printf " '%s'" "$0" "$@" >> config.log
echo >> config.log
echo "#" >> config.log

print_error() {
    (echo
    echo "ERROR: $1"
    while test -n "$2"; do
        echo "       $2"
        shift
    done
    echo) >&2
}

error_exit() {
    print_error "$@"
    exit 1
}

do_compiler() {
    # Run the compiler, capturing its output to the log. First argument
    # is compiler binary to execute.
    local compiler="$1"
    shift
    echo $compiler "$@" >> config.log
    $compiler "$@" >> config.log 2>&1 || return $?
    # Test passed. If this is an --enable-werror build, rerun
    # the test with -Werror and bail out if it fails. This
    # makes warning-generating-errors in configure test code
    # obvious to developers.
    if test "$werror" != "yes"; then
        return 0
    fi
    # Don't bother rerunning the compile if we were already using -Werror
    case "$*" in
        *-Werror*)
           return 0
        ;;
    esac
    echo $compiler -Werror "$@" >> config.log
    $compiler -Werror "$@" >> config.log 2>&1 && return $?
    error_exit "configure test passed without -Werror but failed with -Werror." \
        "This is probably a bug in the configure script. The failing command" \
        "will be at the bottom of config.log." \
        "You can run configure with --disable-werror to bypass this check."
}

do_cc() {
    do_compiler "$cc" "$@"
}

do_cxx() {
    do_compiler "$cxx" "$@"
}

update_cxxflags() {
    # Set QEMU_CXXFLAGS from QEMU_CFLAGS by filtering out those
    # options which some versions of GCC's C++ compiler complain about
    # because they only make sense for C programs.
    QEMU_CXXFLAGS="$QEMU_CXXFLAGS -D__STDC_LIMIT_MACROS"

    for arg in $QEMU_CFLAGS; do
        case $arg in
            -Wstrict-prototypes|-Wmissing-prototypes|-Wnested-externs|\
            -Wold-style-declaration|-Wold-style-definition|-Wredundant-decls)
                ;;
            *)
                QEMU_CXXFLAGS=${QEMU_CXXFLAGS:+$QEMU_CXXFLAGS }$arg
                ;;
        esac
    done
}

compile_object() {
  local_cflags="$1"
  do_cc $QEMU_CFLAGS $local_cflags -c -o $TMPO $TMPC
}

compile_prog() {
  local_cflags="$1"
  local_ldflags="$2"
  do_cc $QEMU_CFLAGS $local_cflags -o $TMPE $TMPC $LDFLAGS $local_ldflags
}

# symbolically link $1 to $2.  Portable version of "ln -sf".
symlink() {
  rm -rf "$2"
  mkdir -p "$(dirname "$2")"
  ln -s "$1" "$2"
}

# check whether a command is available to this shell (may be either an
# executable or a builtin)
has() {
    type "$1" >/dev/null 2>&1
}

# search for an executable in PATH
path_of() {
    local_command="$1"
    local_ifs="$IFS"
    local_dir=""

    # pathname has a dir component?
    if [ "${local_command#*/}" != "$local_command" ]; then
        if [ -x "$local_command" ] && [ ! -d "$local_command" ]; then
            echo "$local_command"
            return 0
        fi
    fi
    if [ -z "$local_command" ]; then
        return 1
    fi

    IFS=:
    for local_dir in $PATH; do
        if [ -x "$local_dir/$local_command" ] && [ ! -d "$local_dir/$local_command" ]; then
            echo "$local_dir/$local_command"
            IFS="${local_ifs:-$(printf ' \t\n')}"
            return 0
        fi
    done
    # not found
    IFS="${local_ifs:-$(printf ' \t\n')}"
    return 1
}

have_backend () {
    echo "$trace_backends" | grep "$1" >/dev/null
}

glob() {
    eval test -z '"${1#'"$2"'}"'
}

supported_kvm_target() {
    test "$kvm" = "yes" || return 1
    glob "$1" "*-softmmu" || return 1
    case "${1%-softmmu}:$cpu" in
        aarch64:aarch64 | x86_64:x86_64 | \
	x86_64:i386 | i386:x86_64)
            return 0
        ;;
    esac
    return 1
}

supported_target() {
    case "$1" in
        *-softmmu)
            ;;
        *)
            print_error "Invalid target name '$target'"
            return 1
            ;;
    esac
    test "$tcg" = "yes" && return 0
    supported_kvm_target "$1" && return 0
    print_error "TCG disabled, but hardware accelerator not available for '$target'"
    return 1
}


ld_has() {
    $ld --help 2>/dev/null | grep ".$1" >/dev/null 2>&1
}

# default parameters
source_path=$(dirname "$0")
cpu=""
iasl="iasl"
interp_prefix="/usr/gnemul/qemu-%M"
static="no"
cross_prefix=""
block_drv_rw_whitelist=""
block_drv_ro_whitelist=""
host_cc="cc"
libs_softmmu=""
libs_tools=""
cc_i386=i386-pc-linux-gnu-gcc
libs_qga=""
debug_info="yes"
stack_protector=""

if test -e "$source_path/.git"
then
    git_update=yes
else
    git_update=no
    git_submodules=""
fi
git="git"

# Don't accept a target_list environment variable.
unset target_list

# Default value for a variable defining feature "foo".
#  * foo="no"  feature will only be used if --enable-foo arg is given
#  * foo=""    feature will be searched for, and if found, will be used
#              unless --disable-foo is given
#  * foo="yes" this value will only be set by --enable-foo flag.
#              feature will searched for,
#              if not found, configure exits with error
#
# Always add --enable-foo and --disable-foo command line args.
# Distributions want to ensure that several features are compiled in, and it
# is impossible without a --enable-foo that exits if a feature is not found.

fdt=""
netmap="no"
virtfs=""
mpath=""
sparse="no"
xkbcommon=""
linux_aio=""
cap_ng=""
attr=""
libattr=""
xfs=""
membarrier=""
vhost_net="no"
vhost_crypto="no"
vhost_scsi="no"
vhost_vsock="no"
vhost_user=""
kvm="no"
piix="no"
gprof="no"
debug="no"
sanitizers="no"
fortify_source=""
strip_opt="yes"
bigendian="no"
gcov="no"
gcov_tool="gcov"
EXESUF=""
DSOSUF=".so"
LDFLAGS_SHARED="-shared"
modules="no"
prefix="/usr/local"
mandir="\${prefix}/share/man"
datadir="\${prefix}/share"
firmwarepath="\${prefix}/share/qemu-firmware"
qemu_docdir="\${prefix}/share/doc/qemu"
bindir="\${prefix}/bin"
libdir="\${prefix}/lib"
libexecdir="\${prefix}/libexec"
includedir="\${prefix}/include"
sysconfdir="\${prefix}/etc"
local_statedir="\${prefix}/var"
confsuffix="/qemu"
slirp="yes"
oss_lib=""
linux="no"
profiler="no"
softmmu="yes"
blobs="yes"
pkgversion=""
pie=""
qom_cast_debug="yes"
trace_backends="log"
trace_file="trace"
rbd=""
cpuid_h="no"
avx2_opt="no"
zlib="yes"
lzo=""
snappy=""
vss_win32_sdk=""
win_sdk="no"
want_tools="yes"
libiscsi=""
libnfs=""
coroutine=""
coroutine_pool=""
debug_stack_usage="no"
crypto_afalg="no"
seccomp=""
tls_priority="NORMAL"
virglrenderer=""
tpm="yes"
libssh2=""
live_block_migration="yes"
numa=""
tcmalloc="no"
jemalloc="no"
replication="yes"
supported_cpu="no"
supported_os="no"
bogus_os="no"
malloc_trim=""

# parse CC options first
for opt do
  optarg=$(expr "x$opt" : 'x[^=]*=\(.*\)')
  case "$opt" in
  --cross-prefix=*) cross_prefix="$optarg"
  ;;
  --cc=*) CC="$optarg"
  ;;
  --cxx=*) CXX="$optarg"
  ;;
  --source-path=*) source_path="$optarg"
  ;;
  --cpu=*) cpu="$optarg"
  ;;
  --extra-cflags=*) QEMU_CFLAGS="$QEMU_CFLAGS $optarg"
  ;;
  --extra-cxxflags=*) QEMU_CXXFLAGS="$QEMU_CXXFLAGS $optarg"
  ;;
  --extra-ldflags=*) LDFLAGS="$LDFLAGS $optarg"
                     EXTRA_LDFLAGS="$optarg"
  ;;
  --enable-debug-info) debug_info="yes"
  ;;
  --disable-debug-info) debug_info="no"
  ;;
  esac
done
# OS specific
# Using uname is really, really broken.  Once we have the right set of checks
# we can eliminate its usage altogether.

# Preferred compiler:
#  ${CC} (if set)
#  ${cross_prefix}gcc (if cross-prefix specified)
#  system compiler
if test -z "${CC}${cross_prefix}"; then
  cc="$host_cc"
else
  cc="${CC-${cross_prefix}gcc}"
fi

if test -z "${CXX}${cross_prefix}"; then
  cxx="c++"
else
  cxx="${CXX-${cross_prefix}g++}"
fi

ar="${AR-${cross_prefix}ar}"
as="${AS-${cross_prefix}as}"
ccas="${CCAS-$cc}"
cpp="${CPP-$cc -E}"
objcopy="${OBJCOPY-${cross_prefix}objcopy}"
ld="${LD-${cross_prefix}ld}"
ranlib="${RANLIB-${cross_prefix}ranlib}"
nm="${NM-${cross_prefix}nm}"
strip="${STRIP-${cross_prefix}strip}"
windres="${WINDRES-${cross_prefix}windres}"
pkg_config_exe="${PKG_CONFIG-${cross_prefix}pkg-config}"
query_pkg_config() {
    "${pkg_config_exe}" ${QEMU_PKG_CONFIG_FLAGS} "$@"
}
pkg_config=query_pkg_config

# If the user hasn't specified ARFLAGS, default to 'rv', just as make does.
ARFLAGS="${ARFLAGS-rv}"

# default flags for all hosts
# We use -fwrapv to tell the compiler that we require a C dialect where
# left shift of signed integers is well defined and has the expected
# 2s-complement style results. (Both clang and gcc agree that it
# provides these semantics.)
QEMU_CFLAGS="-fno-strict-aliasing -fno-common -fwrapv $QEMU_CFLAGS"
QEMU_CFLAGS="-Wall -Wundef -Wwrite-strings -Wmissing-prototypes $QEMU_CFLAGS"
QEMU_CFLAGS="-Wstrict-prototypes -Wredundant-decls $QEMU_CFLAGS"
QEMU_CFLAGS="-D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE $QEMU_CFLAGS"
QEMU_INCLUDES="-iquote . -iquote \$(SRC_PATH) -iquote \$(SRC_PATH)/accel/tcg -iquote \$(SRC_PATH)/include"

if test "$debug_info" = "yes"; then
    CFLAGS="-g $CFLAGS"
    LDFLAGS="-g $LDFLAGS"
fi

# make source path absolute
source_path=$(cd "$source_path"; pwd)

# running configure in the source tree?
# we know that's the case if configure is there.
if test -f "./configure"; then
    pwd_is_source_path="y"
else
    pwd_is_source_path="n"
fi

check_define() {
cat > $TMPC <<EOF
#if !defined($1)
#error $1 not defined
#endif
int main(void) { return 0; }
EOF
  compile_object
}

check_include() {
cat > $TMPC <<EOF
#include <$1>
int main(void) { return 0; }
EOF
  compile_object
}

write_c_skeleton() {
    cat > $TMPC <<EOF
int main(void) { return 0; }
EOF
}

if check_define __linux__ ; then
  targetos="Linux"
else
  # This is a fatal error, but don't report it yet, because we
  # might be going to just print the --help text, or it might
  # be the result of a missing compiler.
  targetos='bogus'
  bogus_os='yes'
fi

if test ! -z "$cpu" ; then
  # command line argument
  :
elif check_define __x86_64__ ; then
    cpu="x86_64"
elif check_define __aarch64__ ; then
  cpu="aarch64"
else
  cpu=$(uname -m)
fi

ARCH=
# Normalise host CPU name and set ARCH.
# Note that this case should only have supported host CPUs, not guests.
case "$cpu" in
  x86_64|amd64)
    cpu="x86_64"
    supported_cpu="yes"
  ;;
  aarch64)
    cpu="aarch64"
    supported_cpu="yes"
  ;;
  *)
    # This will result in either an error or falling back to TCI later
    ARCH=unknown
  ;;
esac
if test -z "$ARCH"; then
  ARCH="$cpu"
fi

# OS specific

# host *BSD for user mode
HOST_VARIANT_DIR=""

case $targetos in
Linux)
  linux="yes"
  kvm="yes"
  vhost_net="yes"
  vhost_crypto="yes"
  vhost_scsi="yes"
  vhost_vsock="yes"
  QEMU_INCLUDES="-I\$(SRC_PATH)/linux-headers -I$(pwd)/linux-headers $QEMU_INCLUDES"
  supported_os="yes"
;;
esac

: ${make=${MAKE-make}}
: ${install=${INSTALL-install}}
: ${python=${PYTHON-python}}
: ${smbd=${SMBD-/usr/sbin/smbd}}

# Default objcc to clang if available, otherwise use CC
if has clang; then
  objcc=clang
else
  objcc="$cc"
fi

werror=""

for opt do
  optarg=$(expr "x$opt" : 'x[^=]*=\(.*\)')
  case "$opt" in
  --help|-h) show_help=yes
  ;;
  --version|-V) exec cat $source_path/VERSION
  ;;
  --prefix=*) prefix="$optarg"
  ;;
  --interp-prefix=*) interp_prefix="$optarg"
  ;;
  --source-path=*)
  ;;
  --cross-prefix=*)
  ;;
  --cc=*)
  ;;
  --host-cc=*) host_cc="$optarg"
  ;;
  --cxx=*)
  ;;
  --iasl=*) iasl="$optarg"
  ;;
  --objcc=*) objcc="$optarg"
  ;;
  --make=*) make="$optarg"
  ;;
  --install=*) install="$optarg"
  ;;
  --python=*) python="$optarg"
  ;;
  --gcov=*) gcov_tool="$optarg"
  ;;
  --smbd=*) smbd="$optarg"
  ;;
  --extra-cflags=*)
  ;;
  --extra-cxxflags=*)
  ;;
  --extra-ldflags=*)
  ;;
  --enable-debug-info)
  ;;
  --disable-debug-info)
  ;;
  --enable-modules)
      modules="yes"
  ;;
  --disable-modules)
      modules="no"
  ;;
  --cpu=*)
  ;;
  --target-list=*) target_list="$optarg"
  ;;
  --enable-trace-backends=*) trace_backends="$optarg"
  ;;
  # XXX: backwards compatibility
  --enable-trace-backend=*) trace_backends="$optarg"
  ;;
  --with-trace-file=*) trace_file="$optarg"
  ;;
  --enable-gprof) gprof="yes"
  ;;
  --enable-gcov) gcov="yes"
  ;;
  --static)
    static="yes"
    LDFLAGS="-static $LDFLAGS"
    QEMU_PKG_CONFIG_FLAGS="--static $QEMU_PKG_CONFIG_FLAGS"
  ;;
  --mandir=*) mandir="$optarg"
  ;;
  --bindir=*) bindir="$optarg"
  ;;
  --libdir=*) libdir="$optarg"
  ;;
  --libexecdir=*) libexecdir="$optarg"
  ;;
  --includedir=*) includedir="$optarg"
  ;;
  --datadir=*) datadir="$optarg"
  ;;
  --with-confsuffix=*) confsuffix="$optarg"
  ;;
  --docdir=*) qemu_docdir="$optarg"
  ;;
  --sysconfdir=*) sysconfdir="$optarg"
  ;;
  --localstatedir=*) local_statedir="$optarg"
  ;;
  --firmwarepath=*) firmwarepath="$optarg"
  ;;
  --sbindir=*|--sharedstatedir=*|\
  --oldincludedir=*|--datarootdir=*|--infodir=*|--localedir=*|\
  --htmldir=*|--dvidir=*|--pdfdir=*|--psdir=*)
    # These switches are silently ignored, for compatibility with
    # autoconf-generated configure scripts. This allows QEMU's
    # configure to be used by RPM and similar macros that set
    # lots of directory switches by default.
  ;;
  --disable-qom-cast-debug) qom_cast_debug="no"
  ;;
  --enable-qom-cast-debug) qom_cast_debug="yes"
  ;;
  --disable-virtfs) virtfs="no"
  ;;
  --enable-virtfs) virtfs="yes"
  ;;
  --disable-mpath) mpath="no"
  ;;
  --enable-mpath) mpath="yes"
  ;;
  --block-drv-rw-whitelist=*|--block-drv-whitelist=*) block_drv_rw_whitelist=$(echo "$optarg" | sed -e 's/,/ /g')
  ;;
  --block-drv-ro-whitelist=*) block_drv_ro_whitelist=$(echo "$optarg" | sed -e 's/,/ /g')
  ;;
  --enable-debug)
      # Enable debugging options that aren't excessively noisy
      debug="yes"
      strip_opt="no"
      fortify_source="no"
  ;;
  --enable-sanitizers) sanitizers="yes"
  ;;
  --disable-sanitizers) sanitizers="no"
  ;;
  --enable-sparse) sparse="yes"
  ;;
  --disable-sparse) sparse="no"
  ;;
  --disable-strip) strip_opt="no"
  ;;
  --disable-slirp) slirp="no"
  ;;
  --disable-netmap) netmap="no"
  ;;
  --enable-netmap) netmap="yes"
  ;;
  --disable-kvm) kvm="no"
  ;;
  --enable-kvm) kvm="yes"
  ;;
  --disable-piix) piix="no"
  ;;
  --enable-piix) piix="yes"
  ;;
  --disable-cap-ng)  cap_ng="no"
  ;;
  --enable-cap-ng) cap_ng="yes"
  ;;
  --disable-malloc-trim) malloc_trim="no"
  ;;
  --enable-malloc-trim) malloc_trim="yes"
  ;;
  --disable-libiscsi) libiscsi="no"
  ;;
  --enable-libiscsi) libiscsi="yes"
  ;;
  --disable-libnfs) libnfs="no"
  ;;
  --enable-libnfs) libnfs="yes"
  ;;
  --enable-profiler) profiler="yes"
  ;;
  --disable-system) softmmu="no"
  ;;
  --enable-system) softmmu="yes"
  ;;
  --enable-pie) pie="yes"
  ;;
  --disable-pie) pie="no"
  ;;
  --enable-werror) werror="yes"
  ;;
  --disable-werror) werror="no"
  ;;
  --enable-stack-protector) stack_protector="yes"
  ;;
  --disable-stack-protector) stack_protector="no"
  ;;
  --disable-fdt) fdt="no"
  ;;
  --enable-fdt) fdt="yes"
  ;;
  --disable-linux-aio) linux_aio="no"
  ;;
  --enable-linux-aio) linux_aio="yes"
  ;;
  --disable-attr) attr="no"
  ;;
  --enable-attr) attr="yes"
  ;;
  --disable-membarrier) membarrier="no"
  ;;
  --enable-membarrier) membarrier="yes"
  ;;
  --disable-blobs) blobs="no"
  ;;
  --with-pkgversion=*) pkgversion="$optarg"
  ;;
  --with-coroutine=*) coroutine="$optarg"
  ;;
  --disable-coroutine-pool) coroutine_pool="no"
  ;;
  --enable-coroutine-pool) coroutine_pool="yes"
  ;;
  --enable-debug-stack-usage) debug_stack_usage="yes"
  ;;
  --enable-crypto-afalg) crypto_afalg="yes"
  ;;
  --disable-crypto-afalg) crypto_afalg="no"
  ;;
  --disable-vhost-net) vhost_net="no"
  ;;
  --enable-vhost-net) vhost_net="yes"
  ;;
  --disable-vhost-crypto) vhost_crypto="no"
  ;;
  --enable-vhost-crypto)
      vhost_crypto="yes"
  ;;
  --disable-vhost-scsi) vhost_scsi="no"
  ;;
  --enable-vhost-scsi) vhost_scsi="yes"
  ;;
  --disable-vhost-vsock) vhost_vsock="no"
  ;;
  --enable-vhost-vsock) vhost_vsock="yes"
  ;;
  --disable-rbd) rbd="no"
  ;;
  --enable-rbd) rbd="yes"
  ;;
  --disable-xfsctl) xfs="no"
  ;;
  --enable-xfsctl) xfs="yes"
  ;;
  --disable-zlib-test) zlib="no"
  ;;
  --disable-lzo) lzo="no"
  ;;
  --enable-lzo) lzo="yes"
  ;;
  --disable-snappy) snappy="no"
  ;;
  --enable-snappy) snappy="yes"
  ;;
  --with-vss-sdk) vss_win32_sdk=""
  ;;
  --with-vss-sdk=*) vss_win32_sdk="$optarg"
  ;;
  --without-vss-sdk) vss_win32_sdk="no"
  ;;
  --with-win-sdk) win_sdk=""
  ;;
  --with-win-sdk=*) win_sdk="$optarg"
  ;;
  --without-win-sdk) win_sdk="no"
  ;;
  --enable-tools) want_tools="yes"
  ;;
  --disable-tools) want_tools="no"
  ;;
  --enable-seccomp) seccomp="yes"
  ;;
  --disable-seccomp) seccomp="no"
  ;;
  --disable-virtio-blk-data-plane|--enable-virtio-blk-data-plane)
      echo "$0: $opt is obsolete, virtio-blk data-plane is always on" >&2
  ;;
  --enable-vhdx|--disable-vhdx)
      echo "$0: $opt is obsolete, VHDX driver is always built" >&2
  ;;
  --enable-uuid|--disable-uuid)
      echo "$0: $opt is obsolete, UUID support is always built" >&2
  ;;
  --tls-priority=*) tls_priority="$optarg"
  ;;
  --disable-virglrenderer) virglrenderer="no"
  ;;
  --enable-virglrenderer) virglrenderer="yes"
  ;;
  --disable-tpm) tpm="no"
  ;;
  --enable-tpm) tpm="yes"
  ;;
  --disable-libssh2) libssh2="no"
  ;;
  --enable-libssh2) libssh2="yes"
  ;;
  --disable-live-block-migration) live_block_migration="no"
  ;;
  --enable-live-block-migration) live_block_migration="yes"
  ;;
  --disable-numa) numa="no"
  ;;
  --enable-numa) numa="yes"
  ;;
  --disable-tcmalloc) tcmalloc="no"
  ;;
  --enable-tcmalloc) tcmalloc="yes"
  ;;
  --disable-jemalloc) jemalloc="no"
  ;;
  --enable-jemalloc) jemalloc="yes"
  ;;
  --disable-replication) replication="no"
  ;;
  --enable-replication) replication="yes"
  ;;
  --disable-vhost-user) vhost_user="no"
  ;;
  --enable-vhost-user)
      vhost_user="yes"
  ;;
  --with-git=*) git="$optarg"
  ;;
  --enable-git-update) git_update=yes
  ;;
  --disable-git-update) git_update=no
  ;;
  *)
      echo "ERROR: unknown option $opt"
      echo "Try '$0 --help' for more information"
      exit 1
  ;;
  esac
done

if test "$vhost_user" = ""; then
        vhost_user="yes"
fi

case "$cpu" in
    x86_64)
           # ??? Only extremely old AMD cpus do not have cmpxchg16b.
           # If we truly care, we should simply detect this case at
           # runtime and generate the fallback to serial emulation.
           CPU_CFLAGS="-m64 -mcx16"
           LDFLAGS="-m64 $LDFLAGS"
           cc_i386='$(CC) -m32'
           ;;
    # No special flags required for other host CPUs
esac

QEMU_CFLAGS="$CPU_CFLAGS $QEMU_CFLAGS"

default_target_list=""

mak_wilds=""

if [ "$softmmu" = "yes" ]; then
    mak_wilds="${mak_wilds} $source_path/default-configs/*-softmmu.mak"
fi

for config in $mak_wilds; do
    default_target_list="${default_target_list} $(basename "$config" .mak)"
done

# Enumerate public trace backends for --help output
trace_backend_list=$(echo $(grep -le '^PUBLIC = True$' "$source_path"/scripts/tracetool/backend/*.py | sed -e 's/^.*\/\(.*\)\.py$/\1/'))

if test x"$show_help" = x"yes" ; then
cat << EOF

Usage: configure [options]
Options: [defaults in brackets after descriptions]

Standard options:
  --help                   print this message
  --prefix=PREFIX          install in PREFIX [$prefix]
  --interp-prefix=PREFIX   where to find shared libraries, etc.
                           use %M for cpu name [$interp_prefix]
  --target-list=LIST       set target list (default: build everything)
$(echo Available targets: $default_target_list | \
  fold -s -w 53 | sed -e 's/^/                           /')

Advanced options (experts only):
  --source-path=PATH       path of source code [$source_path]
  --cross-prefix=PREFIX    use PREFIX for compile tools [$cross_prefix]
  --cc=CC                  use C compiler CC [$cc]
  --iasl=IASL              use ACPI compiler IASL [$iasl]
  --host-cc=CC             use C compiler CC [$host_cc] for code run at
                           build time
  --cxx=CXX                use C++ compiler CXX [$cxx]
  --objcc=OBJCC            use Objective-C compiler OBJCC [$objcc]
  --extra-cflags=CFLAGS    append extra C compiler flags QEMU_CFLAGS
  --extra-cxxflags=CXXFLAGS append extra C++ compiler flags QEMU_CXXFLAGS
  --extra-ldflags=LDFLAGS  append extra linker flags LDFLAGS
  --make=MAKE              use specified make [$make]
  --install=INSTALL        use specified install [$install]
  --python=PYTHON          use specified python [$python]
  --smbd=SMBD              use specified smbd [$smbd]
  --with-git=GIT           use specified git [$git]
  --static                 enable static build [$static]
  --mandir=PATH            install man pages in PATH
  --datadir=PATH           install firmware in PATH$confsuffix
  --docdir=PATH            install documentation in PATH$confsuffix
  --bindir=PATH            install binaries in PATH
  --libdir=PATH            install libraries in PATH
  --libexecdir=PATH        install helper binaries in PATH
  --sysconfdir=PATH        install config in PATH$confsuffix
  --localstatedir=PATH     install local state in PATH (set at runtime on win32)
  --firmwarepath=PATH      search PATH for firmware files
  --with-confsuffix=SUFFIX suffix for QEMU data inside datadir/libdir/sysconfdir [$confsuffix]
  --with-pkgversion=VERS   use specified string as sub-version of the package
  --enable-debug           enable common debug build options
  --enable-sanitizers      enable default sanitizers
  --disable-strip          disable stripping binaries
  --disable-werror         disable compilation abort on warning
  --disable-stack-protector disable compiler-provided stack protection
  --block-drv-whitelist=L  Same as --block-drv-rw-whitelist=L
  --block-drv-rw-whitelist=L
                           set block driver read-write whitelist
                           (affects only QEMU, not qemu-img)
  --block-drv-ro-whitelist=L
                           set block driver read-only whitelist
                           (affects only QEMU, not qemu-img)
  --enable-trace-backends=B Set trace backend
                           Available backends: $trace_backend_list
  --with-trace-file=NAME   Full PATH,NAME of file to store traces
                           Default:trace-<pid>
  --disable-slirp          disable SLIRP userspace network connectivity
  --enable-malloc-trim     enable libc malloc_trim() for memory optimization
  --oss-lib                path to OSS library
  --cpu=CPU                Build for host CPU [$cpu]
  --with-coroutine=BACKEND coroutine backend. Supported options:
                           ucontext, sigaltstack, windows
  --enable-gcov            enable test coverage analysis with gcov
  --gcov=GCOV              use specified gcov [$gcov_tool]
  --disable-blobs          disable installing provided firmware blobs
  --with-vss-sdk=SDK-path  enable Windows VSS support in QEMU Guest Agent
  --with-win-sdk=SDK-path  path to Windows Platform SDK (to build VSS .tlb)
  --tls-priority           default TLS protocol/cipher priority string
  --enable-gprof           QEMU profiling with gprof
  --enable-profiler        profiler support
  --enable-debug-stack-usage
                           track the maximum stack usage of stacks created by qemu_alloc_stack

Optional features, enabled with --enable-FEATURE and
disabled with --disable-FEATURE, default is enabled if available:

  system          all system emulation targets
  pie             Position Independent Executables
  modules         modules support
  debug-info      debugging information
  sparse          sparse checker
  virtfs          VirtFS
  mpath           Multipath persistent reservation passthrough
  membarrier      membarrier system call (for Linux 4.14+ or Windows)
  fdt             fdt device tree
  kvm             KVM acceleration support
  piix            support I440FX platform in kvm for x86 target
  vde             support for vde network
  netmap          support for netmap network
  linux-aio       Linux AIO support
  cap-ng          libcap-ng support
  attr            attr and xattr support
  vhost-net       vhost-net acceleration support
  vhost-crypto    vhost-crypto acceleration support
  rbd             rados block device (rbd)
  libiscsi        iscsi support
  libnfs          nfs support
  live-block-migration   Block migration in the main migration stream
  lzo             support of lzo compression library
  snappy          support of snappy compression library
  seccomp         seccomp support
  coroutine-pool  coroutine freelist (better performance)
  tpm             TPM support
  libssh2         ssh block device support
  numa            libnuma support
  tcmalloc        tcmalloc support
  jemalloc        jemalloc support
  replication     replication support
  vhost-vsock     virtio sockets device support
  virglrenderer   virgl rendering support
  xfsctl          xfsctl support
  qom-cast-debug  cast debugging support
  tools           build qemu-io, qemu-nbd and qemu-image tools
  crypto-afalg    Linux AF_ALG crypto backend driver
  vhost-user      vhost-user support

NOTE: The object files are built at the place where configure is launched
EOF
exit 0
fi

if ! has $python; then
  error_exit "Python not found. Use --python=/path/to/python"
fi

# Note that if the Python conditional here evaluates True we will exit
# with status 1 which is a shell 'false' value.
if ! $python -c 'import sys; sys.exit(sys.version_info < (2,6))'; then
  error_exit "Cannot use '$python', Python 2 >= 2.6 or Python 3 is required." \
      "Use --python=/path/to/python to specify a supported Python."
fi

# Suppress writing compiled files
python="$python -B"

# Check that the C compiler works. Doing this here before testing
# the host CPU ensures that we had a valid CC to autodetect the
# $cpu var (and we should bail right here if that's not the case).
# It also allows the help message to be printed without a CC.
write_c_skeleton;
if compile_object ; then
  : C compiler works ok
else
    error_exit "\"$cc\" either does not exist or does not work"
fi
if ! compile_prog ; then
    error_exit "\"$cc\" cannot build an executable (is your linker broken?)"
fi

# Now we have handled --enable-tcg-interpreter and know we're not just
# printing the help message, bail out if the host CPU isn't supported.
if test "$ARCH" = "unknown"; then
    error_exit "Unsupported CPU = $cpu"
fi

# Consult white-list to determine whether to enable werror
# by default.  Only enable by default for git builds
if test -z "$werror" ; then
    if test -d "$source_path/.git" -a \
        \( "$linux" = "yes"  \) ; then
        werror="yes"
    else
        werror="no"
    fi
fi

if test "$bogus_os" = "yes"; then
    # Now that we know that we're not printing the help and that
    # the compiler works (so the results of the check_defines we used
    # to identify the OS are reliable), if we didn't recognize the
    # host OS we should stop now.
    error_exit "Unrecognized host OS (uname -s reports '$(uname -s)')"
fi

gcc_flags="-Wold-style-declaration -Wold-style-definition -Wtype-limits"
gcc_flags="-Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers $gcc_flags"
gcc_flags="-Wno-missing-include-dirs -Wempty-body -Wnested-externs $gcc_flags"
gcc_flags="-Wendif-labels -Wno-shift-negative-value $gcc_flags"
gcc_flags="-Wno-initializer-overrides -Wexpansion-to-defined $gcc_flags"
gcc_flags="-Wno-string-plus-int $gcc_flags"
gcc_flags="-Wno-error=address-of-packed-member $gcc_flags"
# Note that we do not add -Werror to gcc_flags here, because that would
# enable it for all configure tests. If a configure test failed due
# to -Werror this would just silently disable some features,
# so it's too error prone.

cc_has_warning_flag() {
    write_c_skeleton;

    # Use the positive sense of the flag when testing for -Wno-wombat
    # support (gcc will happily accept the -Wno- form of unknown
    # warning options).
    optflag="$(echo $1 | sed -e 's/^-Wno-/-W/')"
    compile_prog "-Werror $optflag" ""
}

for flag in $gcc_flags; do
    if cc_has_warning_flag $flag ; then
        QEMU_CFLAGS="$QEMU_CFLAGS $flag"
    fi
done

if test "$stack_protector" != "no"; then
  cat > $TMPC << EOF
int main(int argc, char *argv[])
{
    char arr[64], *p = arr, *c = argv[0];
    while (*c) {
        *p++ = *c++;
    }
    return 0;
}
EOF
  gcc_flags="-fstack-protector-strong -fstack-protector-all"
  sp_on=0
  for flag in $gcc_flags; do
    # We need to check both a compile and a link, since some compiler
    # setups fail only on a .c->.o compile and some only at link time
    if do_cc $QEMU_CFLAGS -Werror $flag -c -o $TMPO $TMPC &&
       compile_prog "-Werror $flag" ""; then
      QEMU_CFLAGS="$QEMU_CFLAGS $flag"
      sp_on=1
      break
    fi
  done
  if test "$stack_protector" = yes; then
    if test $sp_on = 0; then
      error_exit "Stack protector not supported"
    fi
  fi
fi

# Disable -Wmissing-braces on older compilers that warn even for
# the "universal" C zero initializer {0}.
cat > $TMPC << EOF
struct {
  int a[2];
} x = {0};
EOF
if compile_object "-Werror" "" ; then
  :
else
  QEMU_CFLAGS="$QEMU_CFLAGS -Wno-missing-braces"
fi

# Workaround for http://gcc.gnu.org/PR55489.  Happens with -fPIE/-fPIC and
# large functions that use global variables.  The bug is in all releases of
# GCC, but it became particularly acute in 4.6.x and 4.7.x.  It is fixed in
# 4.7.3 and 4.8.0.  We should be able to delete this at the end of 2013.
cat > $TMPC << EOF
#if __GNUC__ == 4 && (__GNUC_MINOR__ == 6 || (__GNUC_MINOR__ == 7 && __GNUC_PATCHLEVEL__ <= 2))
int main(void) { return 0; }
#else
#error No bug in this compiler.
#endif
EOF
if compile_prog "-Werror -fno-gcse" "" ; then
  TRANSLATE_OPT_CFLAGS=-fno-gcse
fi

if test "$static" = "yes" ; then
  if test "$modules" = "yes" ; then
    error_exit "static and modules are mutually incompatible"
  fi
  if test "$pie" = "yes" ; then
    error_exit "static and pie are mutually incompatible"
  else
    pie="no"
  fi
fi

# Unconditional check for compiler __thread support
  cat > $TMPC << EOF
static __thread int tls_var;
int main(void) { return tls_var; }
EOF

if ! compile_prog "-Werror" "" ; then
    error_exit "Your compiler does not support the __thread specifier for " \
	"Thread-Local Storage (TLS). Please upgrade to a version that does."
fi

if test "$pie" = ""; then
  case "$cpu-$targetos" in
    x86_64-Linux)
      ;;
    *)
      pie="no"
      ;;
  esac
fi

if test "$pie" != "no" ; then
  cat > $TMPC << EOF

#ifdef __linux__
#  define THREAD __thread
#else
#  define THREAD
#endif

static THREAD int tls_var;

int main(void) { return tls_var; }

EOF
  if compile_prog "-fPIE -DPIE" "-pie"; then
    QEMU_CFLAGS="-fPIE -DPIE $QEMU_CFLAGS"
    LDFLAGS="-pie $LDFLAGS"
    pie="yes"
    if compile_prog "" "-Wl,-z,relro -Wl,-z,now" ; then
      LDFLAGS="-Wl,-z,relro -Wl,-z,now $LDFLAGS"
    fi
  else
    if test "$pie" = "yes"; then
      error_exit "PIE not available due to missing toolchain support"
    else
      echo "Disabling PIE due to missing toolchain support"
      pie="no"
    fi
  fi

  if compile_prog "-Werror -fno-pie" "-nopie"; then
    CFLAGS_NOPIE="-fno-pie"
    LDFLAGS_NOPIE="-nopie"
  fi
fi

##########################################
# __sync_fetch_and_and requires at least -march=i486. Many toolchains
# use i686 as default anyway, but for those that don't, an explicit
# specification is necessary

if test "$cpu" = "i386"; then
  cat > $TMPC << EOF
static int sfaa(int *ptr)
{
  return __sync_fetch_and_and(ptr, 0);
}

int main(void)
{
  int val = 42;
  val = __sync_val_compare_and_swap(&val, 0, 1);
  sfaa(&val);
  return val;
}
EOF
  if ! compile_prog "" "" ; then
    QEMU_CFLAGS="-march=i486 $QEMU_CFLAGS"
  fi
fi

if test -z "${target_list+xxx}" ; then
    for target in $default_target_list; do
        supported_target $target 2>/dev/null && \
            target_list="$target_list $target"
    done
    target_list="${target_list# }"
else
    target_list=$(echo "$target_list" | sed -e 's/,/ /g')
    for target in $target_list; do
        # Check that we recognised the target name; this allows a more
        # friendly error message than if we let it fall through.
        case " $default_target_list " in
            *" $target "*)
                ;;
            *)
                error_exit "Unknown target name '$target'"
                ;;
        esac
        supported_target $target || exit 1
    done
fi

# see if system emulation was really requested
case " $target_list " in
  *"-softmmu "*) softmmu=yes
  ;;
  *) softmmu=no
  ;;
esac

feature_not_found() {
  feature=$1
  remedy=$2

  error_exit "User requested feature $feature" \
      "configure was not able to find it." \
      "$remedy"
}

# ---
# big/little endian test
cat > $TMPC << EOF
short big_endian[] = { 0x4269, 0x4765, 0x4e64, 0x4961, 0x4e00, 0, };
short little_endian[] = { 0x694c, 0x7454, 0x654c, 0x6e45, 0x6944, 0x6e41, 0, };
extern int foo(short *, short *);
int main(int argc, char *argv[]) {
    return foo(big_endian, little_endian);
}
EOF

if compile_object ; then
    if strings -a $TMPO | grep -q BiGeNdIaN ; then
        bigendian="yes"
    elif strings -a $TMPO | grep -q LiTtLeEnDiAn ; then
        bigendian="no"
    else
        echo big/little test failed
    fi
else
    echo big/little test failed
fi

# Some versions of Mac OS X incorrectly define SIZE_MAX
cat > $TMPC << EOF
#include <stdint.h>
#include <stdio.h>
int main(int argc, char *argv[]) {
    return printf("%zu", SIZE_MAX);
}
EOF
have_broken_size_max=no
if ! compile_object -Werror ; then
    have_broken_size_max=yes
fi

##########################################
# L2TPV3 probe

cat > $TMPC <<EOF
#include <sys/socket.h>
#include <linux/ip.h>
int main(void) { return sizeof(struct mmsghdr); }
EOF
if compile_prog "" "" ; then
  l2tpv3=yes
else
  l2tpv3=no
fi

##########################################
# pkg-config probe

if ! has "$pkg_config_exe"; then
  error_exit "pkg-config binary '$pkg_config_exe' not found"
fi

##########################################
# NPTL probe

#########################################
# zlib check

if test "$zlib" != "no" ; then
    cat > $TMPC << EOF
#include <zlib.h>
int main(void) { zlibVersion(); return 0; }
EOF
    if compile_prog "" "-lz" ; then
        :
    else
        error_exit "zlib check failed" \
            "Make sure to have the zlib libs and headers installed."
    fi
fi
LIBS="$LIBS -lz"

##########################################
# lzo check

if test "$lzo" != "no" ; then
    cat > $TMPC << EOF
#include <lzo/lzo1x.h>
int main(void) { lzo_version(); return 0; }
EOF
    if compile_prog "" "-llzo2" ; then
        libs_softmmu="$libs_softmmu -llzo2"
        lzo="yes"
    else
        if test "$lzo" = "yes"; then
            feature_not_found "liblzo2" "Install liblzo2 devel"
        fi
        lzo="no"
    fi
fi

##########################################
# snappy check

if test "$snappy" != "no" ; then
    cat > $TMPC << EOF
#include <snappy-c.h>
int main(void) { snappy_max_compressed_length(4096); return 0; }
EOF
    if compile_prog "" "-lsnappy" ; then
        libs_softmmu="$libs_softmmu -lsnappy"
        snappy="yes"
    else
        if test "$snappy" = "yes"; then
            feature_not_found "libsnappy" "Install libsnappy devel"
        fi
        snappy="no"
    fi
fi

##########################################
# libseccomp check

if test "$seccomp" != "no" ; then
    case "$cpu" in
    x86_64)
        libseccomp_minver="2.1.0"
        ;;
    aarch64)
        libseccomp_minver="2.2.3"
        ;;
    *)
        libseccomp_minver=""
        ;;
    esac

    if test "$libseccomp_minver" != "" &&
       $pkg_config --atleast-version=$libseccomp_minver libseccomp ; then
        seccomp_cflags="$($pkg_config --cflags libseccomp)"
        seccomp_libs="$($pkg_config --libs libseccomp)"
        seccomp="yes"
    else
        if test "$seccomp" = "yes" ; then
            if test "$libseccomp_minver" != "" ; then
                feature_not_found "libseccomp" \
                    "Install libseccomp devel >= $libseccomp_minver"
            else
                feature_not_found "libseccomp" \
                    "libseccomp is not supported for host cpu $cpu"
            fi
        fi
        seccomp="no"
    fi
fi

##########################################
# Sparse probe
if test "$sparse" != "no" ; then
  if has cgcc; then
    sparse=yes
  else
    if test "$sparse" = "yes" ; then
      feature_not_found "sparse" "Install sparse binary"
    fi
    sparse=no
  fi
fi

##########################################
# X11 probe
if $pkg_config --exists "x11"; then
    have_x11=yes
    x11_cflags=$($pkg_config --cflags x11)
    x11_libs=$($pkg_config --libs x11)
fi

##########################################
# libtasn1 - only for the TLS creds/session test suite

tasn1=yes
tasn1_cflags=""
tasn1_libs=""
if $pkg_config --exists "libtasn1"; then
    tasn1_cflags=$($pkg_config --cflags libtasn1)
    tasn1_libs=$($pkg_config --libs libtasn1)
else
    tasn1=no
fi


##########################################
# getifaddrs (for tests/test-io-channel-socket )

have_ifaddrs_h=yes
if ! check_include "ifaddrs.h" ; then
  have_ifaddrs_h=no
fi

##########################################
# xkbcommon probe
if test "$xkbcommon" != "no" ; then
  if $pkg_config xkbcommon --exists; then
    xkbcommon_cflags=$($pkg_config xkbcommon --cflags)
    xkbcommon_libs=$($pkg_config xkbcommon --libs)
    xkbcommon=yes
  else
    if test "$xkbcommon" = "yes" ; then
      feature_not_found "xkbcommon" "Install libxkbcommon-devel"
    fi
    xkbcommon=no
  fi
fi

##########################################
# fnmatch() probe, used for ACL routines
fnmatch="no"
cat > $TMPC << EOF
#include <fnmatch.h>
int main(void)
{
    fnmatch("foo", "foo", 0);
    return 0;
}
EOF
if compile_prog "" "" ; then
   fnmatch="yes"
fi

##########################################
# xfsctl() probe, used for file-posix.c
if test "$xfs" != "no" ; then
  cat > $TMPC << EOF
#include <stddef.h>  /* NULL */
#include <xfs/xfs.h>
int main(void)
{
    xfsctl(NULL, 0, 0, NULL);
    return 0;
}
EOF
  if compile_prog "" "" ; then
    xfs="yes"
  else
    if test "$xfs" = "yes" ; then
      feature_not_found "xfs" "Instal xfsprogs/xfslibs devel"
    fi
    xfs=no
  fi
fi

##########################################
# vde libraries probe
if test "$vde" != "no" ; then
  vde_libs="-lvdeplug"
  cat > $TMPC << EOF
#include <libvdeplug.h>
int main(void)
{
    struct vde_open_args a = {0, 0, 0};
    char s[] = "";
    vde_open(s, s, &a);
    return 0;
}
EOF
  if compile_prog "" "$vde_libs" ; then
    vde=yes
  else
    if test "$vde" = "yes" ; then
      feature_not_found "vde" "Install vde (Virtual Distributed Ethernet) devel"
    fi
    vde=no
  fi
fi

##########################################
# netmap support probe
# Apart from looking for netmap headers, we make sure that the host API version
# supports the netmap backend (>=11). The upper bound (15) is meant to simulate
# a minor/major version number. Minor new features will be marked with values up
# to 15, and if something happens that requires a change to the backend we will
# move above 15, submit the backend fixes and modify this two bounds.
if test "$netmap" != "no" ; then
  cat > $TMPC << EOF
#include <inttypes.h>
#include <net/if.h>
#include <net/netmap.h>
#include <net/netmap_user.h>
#if (NETMAP_API < 11) || (NETMAP_API > 15)
#error
#endif
int main(void) { return 0; }
EOF
  if compile_prog "" "" ; then
    netmap=yes
  else
    if test "$netmap" = "yes" ; then
      feature_not_found "netmap"
    fi
    netmap=no
  fi
fi

##########################################
# libcap-ng library probe
if test "$cap_ng" != "no" ; then
  cap_libs="-lcap-ng"
  cat > $TMPC << EOF
#include <cap-ng.h>
int main(void)
{
    capng_capability_to_name(CAPNG_EFFECTIVE);
    return 0;
}
EOF
  if compile_prog "" "$cap_libs" ; then
    cap_ng=yes
    libs_tools="$cap_libs $libs_tools"
  else
    if test "$cap_ng" = "yes" ; then
      feature_not_found "cap_ng" "Install libcap-ng devel"
    fi
    cap_ng=no
  fi
fi

# glib support probe

    glib_req_ver=2.22
glib_modules=gthread-2.0
if test "$modules" = yes; then
    glib_modules="$glib_modules gmodule-export-2.0"
fi

# This workaround is required due to a bug in pkg-config file for glib as it
# doesn't define GLIB_STATIC_COMPILATION for pkg-config --static

for i in $glib_modules; do
    if $pkg_config --atleast-version=$glib_req_ver $i; then
        glib_cflags=$($pkg_config --cflags $i)
        glib_libs=$($pkg_config --libs $i)
        QEMU_CFLAGS="$glib_cflags $QEMU_CFLAGS"
        LIBS="$glib_libs $LIBS"
        libs_qga="$glib_libs $libs_qga"
    else
        error_exit "glib-$glib_req_ver $i is required to compile QEMU"
    fi
done

# Sanity check that the current size_t matches the
# size that glib thinks it should be. This catches
# problems on multi-arch where people try to build
# 32-bit QEMU while pointing at 64-bit glib headers
cat > $TMPC <<EOF
#include <glib.h>
#include <unistd.h>

#define QEMU_BUILD_BUG_ON(x) \
  typedef char qemu_build_bug_on[(x)?-1:1] __attribute__((unused));

int main(void) {
   QEMU_BUILD_BUG_ON(sizeof(size_t) != GLIB_SIZEOF_SIZE_T);
   return 0;
}
EOF

if ! compile_prog "$CFLAGS" "$LIBS" ; then
    error_exit "sizeof(size_t) doesn't match GLIB_SIZEOF_SIZE_T."\
               "You probably need to set PKG_CONFIG_LIBDIR"\
	       "to point to the right pkg-config files for your"\
	       "build target"
fi

# g_test_trap_subprocess added in 2.38. Used by some tests.
glib_subprocess=yes
if ! $pkg_config --atleast-version=2.38 glib-2.0; then
    glib_subprocess=no
fi

# Silence clang 3.5.0 warnings about glib attribute __alloc_size__ usage
cat > $TMPC << EOF
#include <glib.h>
int main(void) { return 0; }
EOF
if ! compile_prog "$glib_cflags -Werror" "$glib_libs" ; then
    if cc_has_warning_flag "-Wno-unknown-attributes"; then
        glib_cflags="-Wno-unknown-attributes $glib_cflags"
        CFLAGS="-Wno-unknown-attributes $CFLAGS"
    fi
fi

##########################################
# SHA command probe for modules
if test "$modules" = yes; then
    shacmd_probe="sha1sum sha1 shasum"
    for c in $shacmd_probe; do
        if has $c; then
            shacmd="$c"
            break
        fi
    done
    if test "$shacmd" = ""; then
        error_exit "one of the checksum commands is required to enable modules: $shacmd_probe"
    fi
fi

##########################################
# pixman support probe

if test "$want_tools" = "no" -a "$softmmu" = "no"; then
  pixman_cflags=
  pixman_libs=
elif $pkg_config --atleast-version=0.21.8 pixman-1 > /dev/null 2>&1; then
  pixman_cflags=$($pkg_config --cflags pixman-1)
  pixman_libs=$($pkg_config --libs pixman-1)
else
  error_exit "pixman >= 0.21.8 not present." \
      "Please install the pixman devel package."
fi

##########################################
# libmpathpersist probe

if test "$mpath" != "no" ; then
  cat > $TMPC <<EOF
#include <libudev.h>
#include <mpath_persist.h>
unsigned mpath_mx_alloc_len = 1024;
int logsink;
static struct config *multipath_conf;
extern struct udev *udev;
extern struct config *get_multipath_config(void);
extern void put_multipath_config(struct config *conf);
struct udev *udev;
struct config *get_multipath_config(void) { return multipath_conf; }
void put_multipath_config(struct config *conf) { }

int main(void) {
    udev = udev_new();
    multipath_conf = mpath_lib_init();
    return 0;
}
EOF
  if compile_prog "" "-ludev -lmultipath -lmpathpersist" ; then
    mpathpersist=yes
  else
    mpathpersist=no
  fi
else
  mpathpersist=no
fi

##########################################
# libcap probe

if test "$cap" != "no" ; then
  cat > $TMPC <<EOF
#include <stdio.h>
#include <sys/capability.h>
int main(void) { cap_t caps; caps = cap_init(); return caps != NULL; }
EOF
  if compile_prog "" "-lcap" ; then
    cap=yes
  else
    cap=no
  fi
fi

##########################################
# pthread probe
PTHREADLIBS_LIST="-pthread -lpthread -lpthreadGC2"

pthread=no
cat > $TMPC << EOF
#include <pthread.h>
static void *f(void *p) { return NULL; }
int main(void) {
  pthread_t thread;
  pthread_create(&thread, 0, f, 0);
  return 0;
}
EOF
if compile_prog "" "" ; then
  pthread=yes
else
  for pthread_lib in $PTHREADLIBS_LIST; do
    if compile_prog "" "$pthread_lib" ; then
      pthread=yes
      found=no
      for lib_entry in $LIBS; do
        if test "$lib_entry" = "$pthread_lib"; then
          found=yes
          break
        fi
      done
      if test "$found" = "no"; then
        LIBS="$pthread_lib $LIBS"
        libs_qga="$pthread_lib $libs_qga"
      fi
      PTHREAD_LIB="$pthread_lib"
      break
    fi
  done
fi

if test "$pthread" = no; then
  error_exit "pthread check failed" \
      "Make sure to have the pthread libs and headers installed."
fi

# check for pthread_setname_np
pthread_setname_np=no
cat > $TMPC << EOF
#include <pthread.h>

static void *f(void *p) { return NULL; }
int main(void)
{
    pthread_t thread;
    pthread_create(&thread, 0, f, 0);
    pthread_setname_np(thread, "QEMU");
    return 0;
}
EOF
if compile_prog "" "$pthread_lib" ; then
  pthread_setname_np=yes
fi

##########################################
# rbd probe
if test "$rbd" != "no" ; then
  cat > $TMPC <<EOF
#include <stdio.h>
#include <rbd/librbd.h>
int main(void) {
    rados_t cluster;
    rados_create(&cluster, NULL);
    return 0;
}
EOF
  rbd_libs="-lrbd -lrados"
  if compile_prog "" "$rbd_libs" ; then
    rbd=yes
  else
    if test "$rbd" = "yes" ; then
      feature_not_found "rados block device" "Install librbd/ceph devel"
    fi
    rbd=no
  fi
fi

##########################################
# libssh2 probe
min_libssh2_version=1.2.8
if test "$libssh2" != "no" ; then
  if $pkg_config --atleast-version=$min_libssh2_version libssh2; then
    libssh2_cflags=$($pkg_config libssh2 --cflags)
    libssh2_libs=$($pkg_config libssh2 --libs)
    libssh2=yes
  else
    if test "$libssh2" = "yes" ; then
      error_exit "libssh2 >= $min_libssh2_version required for --enable-libssh2"
    fi
    libssh2=no
  fi
fi

##########################################
# libssh2_sftp_fsync probe

if test "$libssh2" = "yes"; then
  cat > $TMPC <<EOF
#include <stdio.h>
#include <libssh2.h>
#include <libssh2_sftp.h>
int main(void) {
    LIBSSH2_SESSION *session;
    LIBSSH2_SFTP *sftp;
    LIBSSH2_SFTP_HANDLE *sftp_handle;
    session = libssh2_session_init ();
    sftp = libssh2_sftp_init (session);
    sftp_handle = libssh2_sftp_open (sftp, "/", 0, 0);
    libssh2_sftp_fsync (sftp_handle);
    return 0;
}
EOF
  # libssh2_cflags/libssh2_libs defined in previous test.
  if compile_prog "$libssh2_cflags" "$libssh2_libs" ; then
    QEMU_CFLAGS="-DHAS_LIBSSH2_SFTP_FSYNC $QEMU_CFLAGS"
  fi
fi

##########################################
# linux-aio probe

if test "$linux_aio" != "no" ; then
  cat > $TMPC <<EOF
#include <libaio.h>
#include <sys/eventfd.h>
#include <stddef.h>
int main(void) { io_setup(0, NULL); io_set_eventfd(NULL, 0); eventfd(0, 0); return 0; }
EOF
  if compile_prog "" "-laio" ; then
    linux_aio=yes
  else
    if test "$linux_aio" = "yes" ; then
      feature_not_found "linux AIO" "Install libaio devel"
    fi
    linux_aio=no
  fi
fi

##########################################
# TPM passthrough is only on x86 Linux

if test "$targetos" = Linux && test "$cpu" = i386 -o "$cpu" = x86_64; then
  tpm_passthrough=$tpm
else
  tpm_passthrough=no
fi

# TPM emulator is for all posix systems
  tpm_emulator=$tpm

##########################################
# attr probe

if test "$attr" != "no" ; then
  cat > $TMPC <<EOF
#include <stdio.h>
#include <sys/types.h>
#ifdef CONFIG_LIBATTR
#include <attr/xattr.h>
#else
#include <sys/xattr.h>
#endif
int main(void) { getxattr(NULL, NULL, NULL, 0); setxattr(NULL, NULL, NULL, 0, 0); return 0; }
EOF
  if compile_prog "" "" ; then
    attr=yes
  # Older distros have <attr/xattr.h>, and need -lattr:
  elif compile_prog "-DCONFIG_LIBATTR" "-lattr" ; then
    attr=yes
    LIBS="-lattr $LIBS"
    libattr=yes
  else
    if test "$attr" = "yes" ; then
      feature_not_found "ATTR" "Install libc6 or libattr devel"
    fi
    attr=no
  fi
fi

##########################################
# iovec probe
cat > $TMPC <<EOF
#include <sys/types.h>
#include <sys/uio.h>
#include <unistd.h>
int main(void) { return sizeof(struct iovec); }
EOF
iovec=no
if compile_prog "" "" ; then
  iovec=yes
fi

##########################################
# preadv probe
cat > $TMPC <<EOF
#include <sys/types.h>
#include <sys/uio.h>
#include <unistd.h>
int main(void) { return preadv(0, 0, 0, 0); }
EOF
preadv=no
if compile_prog "" "" ; then
  preadv=yes
fi

##########################################
# fdt probe
# fdt support is mandatory for at least some target architectures,
# so insist on it if we're building those system emulators.
fdt_required=no
for target in $target_list; do
  case $target in
    aarch64*-softmmu|arm*-softmmu)
      fdt_required=yes
    ;;
  esac
done

if test "$fdt_required" = "yes"; then
  if test "$fdt" = "no"; then
    error_exit "fdt disabled but some requested targets require it." \
      "You can turn off fdt only if you also disable all the system emulation" \
      "targets which need it (by specifying a cut down --target-list)."
  fi
  fdt=yes
fi

if test "$fdt" != "no" ; then
  fdt_libs="-lfdt"
  # explicitly check for libfdt_env.h as it is missing in some stable installs
  # and test for required functions to make sure we are on a version >= 1.4.2
  cat > $TMPC << EOF
#include <libfdt.h>
#include <libfdt_env.h>
int main(void) { fdt_first_subnode(0, 0); return 0; }
EOF
  if compile_prog "" "$fdt_libs" ; then
    # system DTC is good - use it
    fdt=yes
  else
      # have GIT checkout, so activate dtc submodule
      if test -e "${source_path}/.git" ; then
          git_submodules="${git_submodules} dtc"
      fi
      if test -d "${source_path}/dtc/libfdt" || test -e "${source_path}/.git" ; then
          fdt=yes
          dtc_internal="yes"
          mkdir -p dtc
          if [ "$pwd_is_source_path" != "y" ] ; then
              symlink "$source_path/dtc/Makefile" "dtc/Makefile"
              symlink "$source_path/dtc/scripts" "dtc/scripts"
          fi
          fdt_cflags="-I\$(SRC_PATH)/dtc/libfdt"
          fdt_libs="-L\$(BUILD_DIR)/dtc/libfdt $fdt_libs"
      elif test "$fdt" = "yes" ; then
          # Not a git build & no libfdt found, prompt for system install
          error_exit "DTC (libfdt) version >= 1.4.2 not present." \
                     "Please install the DTC (libfdt) devel package"
      else
          # don't have and don't want
          fdt_libs=
          fdt=no
      fi
  fi
fi

libs_softmmu="$libs_softmmu $fdt_libs"

# check if pipe2 is there
pipe2=no
cat > $TMPC << EOF
#include <unistd.h>
#include <fcntl.h>

int main(void)
{
    int pipefd[2];
    return pipe2(pipefd, O_CLOEXEC);
}
EOF
if compile_prog "" "" ; then
  pipe2=yes
fi

# check if accept4 is there
accept4=no
cat > $TMPC << EOF
#include <sys/socket.h>
#include <stddef.h>

int main(void)
{
    accept4(0, NULL, NULL, SOCK_CLOEXEC);
    return 0;
}
EOF
if compile_prog "" "" ; then
  accept4=yes
fi

# check if tee/splice is there. vmsplice was added same time.
splice=no
cat > $TMPC << EOF
#include <unistd.h>
#include <fcntl.h>
#include <limits.h>

int main(void)
{
    int len, fd = 0;
    len = tee(STDIN_FILENO, STDOUT_FILENO, INT_MAX, SPLICE_F_NONBLOCK);
    splice(STDIN_FILENO, NULL, fd, NULL, len, SPLICE_F_MOVE);
    return 0;
}
EOF
if compile_prog "" "" ; then
  splice=yes
fi

##########################################
# libnuma probe

if test "$numa" != "no" ; then
  cat > $TMPC << EOF
#include <numa.h>
int main(void) { return numa_available(); }
EOF

  if compile_prog "" "-lnuma" ; then
    numa=yes
    libs_softmmu="-lnuma $libs_softmmu"
  else
    if test "$numa" = "yes" ; then
      feature_not_found "numa" "install numactl devel"
    fi
    numa=no
  fi
fi

if test "$tcmalloc" = "yes" && test "$jemalloc" = "yes" ; then
    echo "ERROR: tcmalloc && jemalloc can't be used at the same time"
    exit 1
fi

# Even if malloc_trim() is available, these non-libc memory allocators
# do not support it.
if test "$tcmalloc" = "yes" || test "$jemalloc" = "yes" ; then
    if test "$malloc_trim" = "yes" ; then
        echo "Disabling malloc_trim with non-libc memory allocator"
    fi
    malloc_trim="no"
fi

#######################################
# malloc_trim

if test "$malloc_trim" != "no" ; then
    cat > $TMPC << EOF
#include <malloc.h>
int main(void) { malloc_trim(0); return 0; }
EOF
    if compile_prog "" "" ; then
        malloc_trim="yes"
    else
        malloc_trim="no"
    fi
fi

##########################################
# tcmalloc probe

if test "$tcmalloc" = "yes" ; then
  cat > $TMPC << EOF
#include <stdlib.h>
int main(void) { malloc(1); return 0; }
EOF

  if compile_prog "" "-ltcmalloc" ; then
    LIBS="-ltcmalloc $LIBS"
  else
    feature_not_found "tcmalloc" "install gperftools devel"
  fi
fi

##########################################
# jemalloc probe

if test "$jemalloc" = "yes" ; then
  cat > $TMPC << EOF
#include <stdlib.h>
int main(void) { malloc(1); return 0; }
EOF

  if compile_prog "" "-ljemalloc" ; then
    LIBS="-ljemalloc $LIBS"
  else
    feature_not_found "jemalloc" "install jemalloc devel"
  fi
fi

##########################################
# signalfd probe
signalfd="no"
cat > $TMPC << EOF
#include <unistd.h>
#include <sys/syscall.h>
#include <signal.h>
int main(void) { return syscall(SYS_signalfd, -1, NULL, _NSIG / 8); }
EOF

if compile_prog "" "" ; then
  signalfd=yes
fi

# check if eventfd is supported
eventfd=no
cat > $TMPC << EOF
#include <sys/eventfd.h>

int main(void)
{
    return eventfd(0, EFD_NONBLOCK | EFD_CLOEXEC);
}
EOF
if compile_prog "" "" ; then
  eventfd=yes
fi

# check if memfd is supported
memfd=no
cat > $TMPC << EOF
#include <sys/mman.h>

int main(void)
{
    return memfd_create("foo", MFD_ALLOW_SEALING);
}
EOF
if compile_prog "" "" ; then
  memfd=yes
fi



# check for fallocate
fallocate=no
cat > $TMPC << EOF
#include <fcntl.h>

int main(void)
{
    fallocate(0, 0, 0, 0);
    return 0;
}
EOF
if compile_prog "" "" ; then
  fallocate=yes
fi

# check for fallocate hole punching
fallocate_punch_hole=no
cat > $TMPC << EOF
#include <fcntl.h>
#include <linux/falloc.h>

int main(void)
{
    fallocate(0, FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE, 0, 0);
    return 0;
}
EOF
if compile_prog "" "" ; then
  fallocate_punch_hole=yes
fi

# check that fallocate supports range zeroing inside the file
fallocate_zero_range=no
cat > $TMPC << EOF
#include <fcntl.h>
#include <linux/falloc.h>

int main(void)
{
    fallocate(0, FALLOC_FL_ZERO_RANGE, 0, 0);
    return 0;
}
EOF
if compile_prog "" "" ; then
  fallocate_zero_range=yes
fi

# check for posix_fallocate
posix_fallocate=no
cat > $TMPC << EOF
#include <fcntl.h>

int main(void)
{
    posix_fallocate(0, 0, 0);
    return 0;
}
EOF
if compile_prog "" "" ; then
    posix_fallocate=yes
fi

# check for sync_file_range
sync_file_range=no
cat > $TMPC << EOF
#include <fcntl.h>

int main(void)
{
    sync_file_range(0, 0, 0, 0);
    return 0;
}
EOF
if compile_prog "" "" ; then
  sync_file_range=yes
fi

# check for linux/fiemap.h and FS_IOC_FIEMAP
fiemap=no
cat > $TMPC << EOF
#include <sys/ioctl.h>
#include <linux/fs.h>
#include <linux/fiemap.h>

int main(void)
{
    ioctl(0, FS_IOC_FIEMAP, 0);
    return 0;
}
EOF
if compile_prog "" "" ; then
  fiemap=yes
fi

# check for dup3
dup3=no
cat > $TMPC << EOF
#include <unistd.h>

int main(void)
{
    dup3(0, 0, 0);
    return 0;
}
EOF
if compile_prog "" "" ; then
  dup3=yes
fi

# check for ppoll support
ppoll=no
cat > $TMPC << EOF
#include <poll.h>

int main(void)
{
    struct pollfd pfd = { .fd = 0, .events = 0, .revents = 0 };
    ppoll(&pfd, 1, 0, 0);
    return 0;
}
EOF
if compile_prog "" "" ; then
  ppoll=yes
fi

# check for prctl(PR_SET_TIMERSLACK , ... ) support
prctl_pr_set_timerslack=no
cat > $TMPC << EOF
#include <sys/prctl.h>

int main(void)
{
    prctl(PR_SET_TIMERSLACK, 1, 0, 0, 0);
    return 0;
}
EOF
if compile_prog "" "" ; then
  prctl_pr_set_timerslack=yes
fi

# check for epoll support
epoll=no
cat > $TMPC << EOF
#include <sys/epoll.h>

int main(void)
{
    epoll_create(0);
    return 0;
}
EOF
if compile_prog "" "" ; then
  epoll=yes
fi

# epoll_create1 is a later addition
# so we must check separately for its presence
epoll_create1=no
cat > $TMPC << EOF
#include <sys/epoll.h>

int main(void)
{
    /* Note that we use epoll_create1 as a value, not as
     * a function being called. This is necessary so that on
     * old SPARC glibc versions where the function was present in
     * the library but not declared in the header file we will
     * fail the configure check. (Otherwise we will get a compiler
     * warning but not an error, and will proceed to fail the
     * qemu compile where we compile with -Werror.)
     */
    return (int)(uintptr_t)&epoll_create1;
}
EOF
if compile_prog "" "" ; then
  epoll_create1=yes
fi

# check for sendfile support
sendfile=no
cat > $TMPC << EOF
#include <sys/sendfile.h>

int main(void)
{
    return sendfile(0, 0, 0, 0);
}
EOF
if compile_prog "" "" ; then
  sendfile=yes
fi

# check for timerfd support (glibc 2.8 and newer)
timerfd=no
cat > $TMPC << EOF
#include <sys/timerfd.h>

int main(void)
{
    return(timerfd_create(CLOCK_REALTIME, 0));
}
EOF
if compile_prog "" "" ; then
  timerfd=yes
fi

# check for setns and unshare support
setns=no
cat > $TMPC << EOF
#include <sched.h>

int main(void)
{
    int ret;
    ret = setns(0, 0);
    ret = unshare(0);
    return ret;
}
EOF
if compile_prog "" "" ; then
  setns=yes
fi

# clock_adjtime probe
clock_adjtime=no
cat > $TMPC <<EOF
#include <time.h>

int main(void)
{
    return clock_adjtime(0, 0);
}
EOF
clock_adjtime=no
if compile_prog "" "" ; then
  clock_adjtime=yes
fi

# syncfs probe
syncfs=no
cat > $TMPC <<EOF
#include <unistd.h>

int main(void)
{
    return syncfs(0);
}
EOF
syncfs=no
if compile_prog "" "" ; then
  syncfs=yes
fi

# Search for bswap_32 function
byteswap_h=no
cat > $TMPC << EOF
#include <byteswap.h>
int main(void) { return bswap_32(0); }
EOF
if compile_prog "" "" ; then
  byteswap_h=yes
fi

# Search for bswap32 function
bswap_h=no
cat > $TMPC << EOF
#include <sys/endian.h>
#include <sys/types.h>
#include <machine/bswap.h>
int main(void) { return bswap32(0); }
EOF
if compile_prog "" "" ; then
  bswap_h=yes
fi

##########################################
# Do we have libiscsi >= 1.9.0
if test "$libiscsi" != "no" ; then
  if $pkg_config --atleast-version=1.9.0 libiscsi; then
    libiscsi="yes"
    libiscsi_cflags=$($pkg_config --cflags libiscsi)
    libiscsi_libs=$($pkg_config --libs libiscsi)
  else
    if test "$libiscsi" = "yes" ; then
      feature_not_found "libiscsi" "Install libiscsi >= 1.9.0"
    fi
    libiscsi="no"
  fi
fi

##########################################
# Do we need libm
cat > $TMPC << EOF
#include <math.h>
int main(int argc, char **argv) { return isnan(sin((double)argc)); }
EOF
if compile_prog "" "" ; then
  :
elif compile_prog "" "-lm" ; then
  LIBS="-lm $LIBS"
  libs_qga="-lm $libs_qga"
else
  error_exit "libm check failed"
fi

##########################################
# Do we need librt
# uClibc provides 2 versions of clock_gettime(), one with realtime
# support and one without. This means that the clock_gettime() don't
# need -lrt. We still need it for timer_create() so we check for this
# function in addition.
cat > $TMPC <<EOF
#include <signal.h>
#include <time.h>
int main(void) {
  timer_create(CLOCK_REALTIME, NULL, NULL);
  return clock_gettime(CLOCK_REALTIME, NULL);
}
EOF

if compile_prog "" "" ; then
  :
# we need pthread for static linking. use previous pthread test result
elif compile_prog "" "$pthread_lib -lrt" ; then
  LIBS="$LIBS -lrt"
  libs_qga="$libs_qga -lrt"
fi

    libs_softmmu="-lutil $libs_softmmu"

##########################################
# virgl renderer probe

if test "$virglrenderer" != "no" ; then
  cat > $TMPC << EOF
#include <virglrenderer.h>
int main(void) { virgl_renderer_poll(); return 0; }
EOF
  virgl_cflags=$($pkg_config --cflags virglrenderer 2>/dev/null)
  virgl_libs=$($pkg_config --libs virglrenderer 2>/dev/null)
  if $pkg_config virglrenderer >/dev/null 2>&1 && \
     compile_prog "$virgl_cflags" "$virgl_libs" ; then
    virglrenderer="yes"
  else
    if test "$virglrenderer" = "yes" ; then
      feature_not_found "virglrenderer"
    fi
    virglrenderer="no"
  fi
fi

##########################################
# check if we have fdatasync

fdatasync=no
cat > $TMPC << EOF
#include <unistd.h>
int main(void) {
#if defined(_POSIX_SYNCHRONIZED_IO) && _POSIX_SYNCHRONIZED_IO > 0
return fdatasync(0);
#else
#error Not supported
#endif
}
EOF
if compile_prog "" "" ; then
    fdatasync=yes
fi

##########################################
# check if we have madvise

madvise=no
cat > $TMPC << EOF
#include <sys/types.h>
#include <sys/mman.h>
#include <stddef.h>
int main(void) { return madvise(NULL, 0, MADV_DONTNEED); }
EOF
if compile_prog "" "" ; then
    madvise=yes
fi

##########################################
# check if we have posix_madvise

posix_madvise=no
cat > $TMPC << EOF
#include <sys/mman.h>
#include <stddef.h>
int main(void) { return posix_madvise(NULL, 0, POSIX_MADV_DONTNEED); }
EOF
if compile_prog "" "" ; then
    posix_madvise=yes
fi

##########################################
# check if we have posix_memalign()

posix_memalign=no
cat > $TMPC << EOF
#include <stdlib.h>
int main(void) {
    void *p;
    return posix_memalign(&p, 8, 8);
}
EOF
if compile_prog "" "" ; then
    posix_memalign=yes
fi

##########################################
# check if we have posix_syslog

posix_syslog=no
cat > $TMPC << EOF
#include <syslog.h>
int main(void) { openlog("qemu", LOG_PID, LOG_DAEMON); syslog(LOG_INFO, "configure"); return 0; }
EOF
if compile_prog "" "" ; then
    posix_syslog=yes
fi

##########################################
# check if we have sem_timedwait

sem_timedwait=no
cat > $TMPC << EOF
#include <semaphore.h>
int main(void) { return sem_timedwait(0, 0); }
EOF
if compile_prog "" "" ; then
    sem_timedwait=yes
fi

##########################################
# check if trace backend exists

$python "$source_path/scripts/tracetool.py" "--backends=$trace_backends" --check-backends  > /dev/null 2> /dev/null
if test "$?" -ne 0 ; then
  error_exit "invalid trace backends" \
      "Please choose supported trace backends."
fi

##########################################
# For 'ust' backend, test if ust headers are present
if have_backend "ust"; then
  cat > $TMPC << EOF
#include <lttng/tracepoint.h>
int main(void) { return 0; }
EOF
  if compile_prog "" "-Wl,--no-as-needed -ldl" ; then
    if $pkg_config lttng-ust --exists; then
      lttng_ust_libs=$($pkg_config --libs lttng-ust)
    else
      lttng_ust_libs="-llttng-ust -ldl"
    fi
    if $pkg_config liburcu-bp --exists; then
      urcu_bp_libs=$($pkg_config --libs liburcu-bp)
    else
      urcu_bp_libs="-lurcu-bp"
    fi

    LIBS="$lttng_ust_libs $urcu_bp_libs $LIBS"
    libs_qga="$lttng_ust_libs $urcu_bp_libs $libs_qga"
  else
    error_exit "Trace backend 'ust' missing lttng-ust header files"
  fi
fi

##########################################
# For 'dtrace' backend, test if 'dtrace' command is present
if have_backend "dtrace"; then
  if ! has 'dtrace' ; then
    error_exit "dtrace command is not found in PATH $PATH"
  fi
  trace_backend_stap="no"
  if has 'stap' ; then
    trace_backend_stap="yes"
  fi
fi

##########################################
# check and set a backend for coroutine

# We prefer ucontext, but it's not always possible. The fallback
# is sigcontext. On Windows the only valid backend is the Windows
# specific one.

ucontext_works=no
if test "$darwin" != "yes"; then
  cat > $TMPC << EOF
#include <ucontext.h>
#ifdef __stub_makecontext
#error Ignoring glibc stub makecontext which will always fail
#endif
int main(void) { makecontext(0, 0, 0); return 0; }
EOF
  if compile_prog "" "" ; then
    ucontext_works=yes
  fi
fi

if test "$coroutine" = ""; then
  if test "$ucontext_works" = "yes"; then
    coroutine=ucontext
  else
    coroutine=sigaltstack
  fi
else
  case $coroutine in
  ucontext)
    if test "$ucontext_works" != "yes"; then
      feature_not_found "ucontext"
    fi
    ;;
  *)
    error_exit "unknown coroutine backend $coroutine"
    ;;
  esac
fi

if test "$coroutine_pool" = ""; then
  coroutine_pool=yes
fi

if test "$debug_stack_usage" = "yes"; then
  if test "$coroutine_pool" = "yes"; then
    echo "WARN: disabling coroutine pool for stack usage debugging"
    coroutine_pool=no
  fi
fi


##########################################
# check if we have open_by_handle_at

open_by_handle_at=no
cat > $TMPC << EOF
#include <fcntl.h>
#if !defined(AT_EMPTY_PATH)
# error missing definition
#else
int main(void) { struct file_handle fh; return open_by_handle_at(0, &fh, 0); }
#endif
EOF
if compile_prog "" "" ; then
    open_by_handle_at=yes
fi

########################################
# check if we have linux/magic.h

linux_magic_h=no
cat > $TMPC << EOF
#include <linux/magic.h>
int main(void) {
  return 0;
}
EOF
if compile_prog "" "" ; then
    linux_magic_h=yes
fi

########################################
# check whether we can disable warning option with a pragma (this is needed
# to silence warnings in the headers of some versions of external libraries).
# This test has to be compiled with -Werror as otherwise an unknown pragma is
# only a warning.
#
# If we can't selectively disable warning in the code, disable -Werror so that
# the build doesn't fail anyway.

pragma_disable_unused_but_set=no
cat > $TMPC << EOF
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-prototypes"
#pragma GCC diagnostic pop

int main(void) {
    return 0;
}
EOF
if compile_prog "-Werror" "" ; then
    pragma_diagnostic_available=yes
else
    werror=no
fi

########################################
# check if we have valgrind/valgrind.h

valgrind_h=no
cat > $TMPC << EOF
#include <valgrind/valgrind.h>
int main(void) {
  return 0;
}
EOF
if compile_prog "" "" ; then
    valgrind_h=yes
fi

########################################
# check if environ is declared

has_environ=no
cat > $TMPC << EOF
#include <unistd.h>
int main(void) {
    environ = 0;
    return 0;
}
EOF
if compile_prog "" "" ; then
    has_environ=yes
fi

########################################
# check if cpuid.h is usable.

cat > $TMPC << EOF
#include <cpuid.h>
int main(void) {
    unsigned a, b, c, d;
    int max = __get_cpuid_max(0, 0);

    if (max >= 1) {
        __cpuid(1, a, b, c, d);
    }

    if (max >= 7) {
        __cpuid_count(7, 0, a, b, c, d);
    }

    return 0;
}
EOF
if compile_prog "" "" ; then
    cpuid_h=yes
fi

##########################################
# avx2 optimization requirement check
#
# There is no point enabling this if cpuid.h is not usable,
# since we won't be able to select the new routines.

if test $cpuid_h = yes; then
  cat > $TMPC << EOF
#pragma GCC push_options
#pragma GCC target("avx2")
#include <cpuid.h>
#include <immintrin.h>
static int bar(void *a) {
    __m256i x = *(__m256i *)a;
    return _mm256_testz_si256(x, x);
}
int main(int argc, char *argv[]) { return bar(argv[0]); }
EOF
  if compile_object "" ; then
    avx2_opt="yes"
  fi
fi

########################################
# check if __[u]int128_t is usable.

int128=no
cat > $TMPC << EOF
#if defined(__clang_major__) && defined(__clang_minor__)
# if ((__clang_major__ < 3) || (__clang_major__ == 3) && (__clang_minor__ < 2))
#  error __int128_t does not work in CLANG before 3.2
# endif
#endif
__int128_t a;
__uint128_t b;
int main (void) {
  a = a + b;
  b = a * b;
  a = a * a;
  return 0;
}
EOF
if compile_prog "" "" ; then
    int128=yes
fi

#########################################
# See if 128-bit atomic operations are supported.

atomic128=no
if test "$int128" = "yes"; then
  cat > $TMPC << EOF
int main(void)
{
  unsigned __int128 x = 0, y = 0;
  y = __atomic_load_16(&x, 0);
  __atomic_store_16(&x, y, 0);
  __atomic_compare_exchange_16(&x, &y, x, 0, 0, 0);
  return 0;
}
EOF
  if compile_prog "" "" ; then
    atomic128=yes
  fi
fi

#########################################
# See if 64-bit atomic operations are supported.
# Note that without __atomic builtins, we can only
# assume atomic loads/stores max at pointer size.

cat > $TMPC << EOF
#include <stdint.h>
int main(void)
{
  uint64_t x = 0, y = 0;
#ifdef __ATOMIC_RELAXED
  y = __atomic_load_8(&x, 0);
  __atomic_store_8(&x, y, 0);
  __atomic_compare_exchange_8(&x, &y, x, 0, 0, 0);
  __atomic_exchange_8(&x, y, 0);
  __atomic_fetch_add_8(&x, y, 0);
#else
  typedef char is_host64[sizeof(void *) >= sizeof(uint64_t) ? 1 : -1];
  __sync_lock_test_and_set(&x, y);
  __sync_val_compare_and_swap(&x, y, 0);
  __sync_fetch_and_add(&x, y);
#endif
  return 0;
}
EOF
if compile_prog "" "" ; then
  atomic64=yes
fi

########################################
# See if 16-byte vector operations are supported.
# Even without a vector unit the compiler may expand these.
# There is a bug in old GCC for PPC that crashes here.
# Unfortunately it's the system compiler for Centos 7.

cat > $TMPC << EOF
typedef unsigned char U1 __attribute__((vector_size(16)));
typedef unsigned short U2 __attribute__((vector_size(16)));
typedef unsigned int U4 __attribute__((vector_size(16)));
typedef unsigned long long U8 __attribute__((vector_size(16)));
typedef signed char S1 __attribute__((vector_size(16)));
typedef signed short S2 __attribute__((vector_size(16)));
typedef signed int S4 __attribute__((vector_size(16)));
typedef signed long long S8 __attribute__((vector_size(16)));
static U1 a1, b1;
static U2 a2, b2;
static U4 a4, b4;
static U8 a8, b8;
static S1 c1;
static S2 c2;
static S4 c4;
static S8 c8;
static int i;
void helper(void *d, void *a, int shift, int i);
void helper(void *d, void *a, int shift, int i)
{
  *(U1 *)(d + i) = *(U1 *)(a + i) << shift;
  *(U2 *)(d + i) = *(U2 *)(a + i) << shift;
  *(U4 *)(d + i) = *(U4 *)(a + i) << shift;
  *(U8 *)(d + i) = *(U8 *)(a + i) << shift;
}
int main(void)
{
  a1 += b1; a2 += b2; a4 += b4; a8 += b8;
  a1 -= b1; a2 -= b2; a4 -= b4; a8 -= b8;
  a1 *= b1; a2 *= b2; a4 *= b4; a8 *= b8;
  a1 &= b1; a2 &= b2; a4 &= b4; a8 &= b8;
  a1 |= b1; a2 |= b2; a4 |= b4; a8 |= b8;
  a1 ^= b1; a2 ^= b2; a4 ^= b4; a8 ^= b8;
  a1 <<= i; a2 <<= i; a4 <<= i; a8 <<= i;
  a1 >>= i; a2 >>= i; a4 >>= i; a8 >>= i;
  c1 >>= i; c2 >>= i; c4 >>= i; c8 >>= i;
  return 0;
}
EOF

vector16=no
if compile_prog "" "" ; then
  vector16=yes
fi

########################################
# check if getauxval is available.

getauxval=no
cat > $TMPC << EOF
#include <sys/auxv.h>
int main(void) {
  return getauxval(AT_HWCAP) == 0;
}
EOF
if compile_prog "" "" ; then
    getauxval=yes
fi

########################################
# check if ccache is interfering with
# semantic analysis of macros

unset CCACHE_CPP2
ccache_cpp2=no
cat > $TMPC << EOF
static const int Z = 1;
#define fn() ({ Z; })
#define TAUT(X) ((X) == Z)
#define PAREN(X, Y) (X == Y)
#define ID(X) (X)
int main(int argc, char *argv[])
{
    int x = 0, y = 0;
    x = ID(x);
    x = fn();
    fn();
    if (PAREN(x, y)) return 0;
    if (TAUT(Z)) return 0;
    return 0;
}
EOF

if ! compile_object "-Werror"; then
    ccache_cpp2=yes
fi

#################################################
# clang does not support glibc + FORTIFY_SOURCE.

if test "$fortify_source" != "no"; then
  if echo | $cc -dM -E - | grep __clang__ > /dev/null 2>&1 ; then
    fortify_source="no";
  elif test -n "$cxx" && has $cxx &&
       echo | $cxx -dM -E - | grep __clang__ >/dev/null 2>&1 ; then
    fortify_source="no";
  else
    fortify_source="yes"
  fi
fi

##########################################
# check if struct fsxattr is available via linux/fs.h

have_fsxattr=no
cat > $TMPC << EOF
#include <linux/fs.h>
struct fsxattr foo;
int main(void) {
  return 0;
}
EOF
if compile_prog "" "" ; then
    have_fsxattr=yes
fi

##########################################
# check for usable membarrier system call
if test "$membarrier" = "yes"; then
    have_membarrier=no
    if test "$linux" = "yes" ; then
        cat > $TMPC << EOF
    #include <linux/membarrier.h>
    #include <sys/syscall.h>
    #include <unistd.h>
    #include <stdlib.h>
    int main(void) {
        syscall(__NR_membarrier, MEMBARRIER_CMD_QUERY, 0);
        syscall(__NR_membarrier, MEMBARRIER_CMD_SHARED, 0);
	exit(0);
    }
EOF
        if compile_prog "" "" ; then
            have_membarrier=yes
        fi
    fi
    if test "$have_membarrier" = "no"; then
      feature_not_found "membarrier" "membarrier system call not available"
    fi
else
    # Do not enable it by default even for Mingw32, because it doesn't
    # work on Wine.
    membarrier=no
fi

##########################################
# check if rtnetlink.h exists and is useful
have_rtnetlink=no
cat > $TMPC << EOF
#include <linux/rtnetlink.h>
int main(void) {
  return IFLA_PROTO_DOWN;
}
EOF
if compile_prog "" "" ; then
    have_rtnetlink=yes
fi

##########################################
# check for usable AF_VSOCK environment
have_af_vsock=no
cat > $TMPC << EOF
#include <errno.h>
#include <sys/types.h>
#include <sys/socket.h>
#if !defined(AF_VSOCK)
# error missing AF_VSOCK flag
#endif
#include <linux/vm_sockets.h>
int main(void) {
    int sock, ret;
    struct sockaddr_vm svm;
    socklen_t len = sizeof(svm);
    sock = socket(AF_VSOCK, SOCK_STREAM, 0);
    ret = getpeername(sock, (struct sockaddr *)&svm, &len);
    if ((ret == -1) && (errno == ENOTCONN)) {
        return 0;
    }
    return -1;
}
EOF
if compile_prog "" "" ; then
    have_af_vsock=yes
fi

##########################################
# check for usable AF_ALG environment
hava_afalg=no
cat > $TMPC << EOF
#include <errno.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <linux/if_alg.h>
int main(void) {
    int sock;
    sock = socket(AF_ALG, SOCK_SEQPACKET, 0);
    return sock;
}
EOF
if compile_prog "" "" ; then
    have_afalg=yes
fi
if test "$crypto_afalg" = "yes"
then
    if test "$have_afalg" != "yes"
    then
	error_exit "AF_ALG requested but could not be detected"
    fi
fi


#################################################
# Sparc implicitly links with --relax, which is
# incompatible with -r, so --no-relax should be
# given. It does no harm to give it on other
# platforms too.

# Note: the prototype is needed since QEMU_CFLAGS
#       contains -Wmissing-prototypes
cat > $TMPC << EOF
extern int foo(void);
int foo(void) { return 0; }
EOF
if ! compile_object ""; then
  error_exit "Failed to compile object file for LD_REL_FLAGS test"
fi
for i in '-Wl,-r -Wl,--no-relax' -Wl,-r -r; do
  if do_cc -nostdlib $i -o $TMPMO $TMPO; then
    LD_REL_FLAGS=$i
    break
  fi
done
if test "$modules" = "yes" && test "$LD_REL_FLAGS" = ""; then
  feature_not_found "modules" "Cannot find how to build relocatable objects"
fi

##########################################
# check for sysmacros.h

have_sysmacros=no
cat > $TMPC << EOF
#include <sys/sysmacros.h>
int main(void) {
    return makedev(0, 0);
}
EOF
if compile_prog "" "" ; then
    have_sysmacros=yes
fi

##########################################
# check for _Static_assert()

have_static_assert=no
cat > $TMPC << EOF
_Static_assert(1, "success");
int main(void) {
    return 0;
}
EOF
if compile_prog "" "" ; then
    have_static_assert=yes
fi

##########################################
# check for utmpx.h, it is missing e.g. on OpenBSD

have_utmpx=no
cat > $TMPC << EOF
#include <utmpx.h>
struct utmpx user_info;
int main(void) {
    return 0;
}
EOF
if compile_prog "" "" ; then
    have_utmpx=yes
fi

##########################################
# checks for sanitizers

have_asan=no
have_ubsan=no
have_asan_iface_h=no
have_asan_iface_fiber=no

if test "$sanitizers" = "yes" ; then
  write_c_skeleton
  if compile_prog "$CPU_CFLAGS -Werror -fsanitize=address" ""; then
      have_asan=yes
  fi

  # we could use a simple skeleton for flags checks, but this also
  # detect the static linking issue of ubsan, see also:
  # https://gcc.gnu.org/bugzilla/show_bug.cgi?id=84285
  cat > $TMPC << EOF
#include <stdlib.h>
int main(void) {
    void *tmp = malloc(10);
    return *(int *)(tmp + 2);
}
EOF
  if compile_prog "$CPU_CFLAGS -Werror -fsanitize=undefined" ""; then
      have_ubsan=yes
  fi

  if check_include "sanitizer/asan_interface.h" ; then
      have_asan_iface_h=yes
  fi

  cat > $TMPC << EOF
#include <sanitizer/asan_interface.h>
int main(void) {
  __sanitizer_start_switch_fiber(0, 0, 0);
  return 0;
}
EOF
  if compile_prog "$CPU_CFLAGS -Werror -fsanitize=address" "" ; then
      have_asan_iface_fiber=yes
  fi
fi

##########################################
# End of CC checks
# After here, no more $cc or $ld runs

write_c_skeleton

if test "$gcov" = "yes" ; then
  CFLAGS="-fprofile-arcs -ftest-coverage -g $CFLAGS"
  LDFLAGS="-fprofile-arcs -ftest-coverage $LDFLAGS"
elif test "$fortify_source" = "yes" ; then
  CFLAGS="-O2 -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=2 $CFLAGS"
elif test "$debug" = "no"; then
  CFLAGS="-O2 $CFLAGS"
fi

if test "$have_asan" = "yes"; then
  CFLAGS="-fsanitize=address $CFLAGS"
  if test "$have_asan_iface_h" = "no" ; then
      echo "ASAN build enabled, but ASAN header missing." \
           "Without code annotation, the report may be inferior."
  elif test "$have_asan_iface_fiber" = "no" ; then
      echo "ASAN build enabled, but ASAN header is too old." \
           "Without code annotation, the report may be inferior."
  fi
fi
if test "$have_ubsan" = "yes"; then
  CFLAGS="-fsanitize=undefined $CFLAGS"
fi

##########################################
# Do we have libnfs
if test "$libnfs" != "no" ; then
  if $pkg_config --atleast-version=1.9.3 libnfs; then
    libnfs="yes"
    libnfs_libs=$($pkg_config --libs libnfs)
  else
    if test "$libnfs" = "yes" ; then
      feature_not_found "libnfs" "Install libnfs devel >= 1.9.3"
    fi
    libnfs="no"
  fi
fi

# Now we've finished running tests it's OK to add -Werror to the compiler flags
if test "$werror" = "yes"; then
    QEMU_CFLAGS="-Werror $QEMU_CFLAGS"
fi

if $ld --version 2>/dev/null | grep "GNU ld" >/dev/null 2>/dev/null ; then
    LDFLAGS="-Wl,--warn-common $LDFLAGS"
fi

# test if pod2man has --utf8 option
if pod2man --help | grep -q utf8; then
    POD2MAN="pod2man --utf8"
else
    POD2MAN="pod2man"
fi

qemu_confdir=$sysconfdir$confsuffix
qemu_moddir=$libdir$confsuffix
qemu_datadir=$datadir$confsuffix
qemu_localedir="$datadir/locale"

# We can only support ivshmem if we have eventfd
if [ "$eventfd" = "yes" ]; then
  ivshmem=yes
fi

tools=""
if test "$want_tools" = "yes" ; then
  tools="qemu-img\$(EXESUF) qemu-io\$(EXESUF) $tools"
  if [ "$linux" = "yes" ] ; then
    tools="qemu-nbd\$(EXESUF) $tools"
  fi
  if [ "$ivshmem" = "yes" ]; then
    tools="ivshmem-client\$(EXESUF) ivshmem-server\$(EXESUF) $tools"
  fi
fi
if test "$softmmu" = yes ; then
  if test "$linux" = yes; then
    if test "$virtfs" != no && test "$cap" = yes && test "$attr" = yes ; then
      virtfs=yes
      tools="$tools fsdev/virtfs-proxy-helper\$(EXESUF)"
    else
      if test "$virtfs" = yes; then
        error_exit "VirtFS requires libcap devel and libattr devel"
      fi
      virtfs=no
    fi
    if test "$mpath" != no && test "$mpathpersist" = yes ; then
      mpath=yes
    else
      if test "$mpath" = yes; then
        error_exit "Multipath requires libmpathpersist devel"
      fi
      mpath=no
    fi
    tools="$tools scsi/qemu-pr-helper\$(EXESUF)"
  else
    if test "$virtfs" = yes; then
      error_exit "VirtFS is supported only on Linux"
    fi
    virtfs=no
    if test "$mpath" = yes; then
      error_exit "Multipath is supported only on Linux"
    fi
    mpath=no
  fi
  if test "$xkbcommon" = "yes"; then
    tools="qemu-keymap\$(EXESUF) $tools"
  fi
fi

# Mac OS X ships with a broken assembler
roms=
if test \( "$cpu" = "x86_64" \) -a "$softmmu" = yes ; then
    # Different host OS linkers have different ideas about the name of the ELF
    # emulation. Linux and OpenBSD/amd64 use 'elf_i386'; FreeBSD uses the _fbsd
    # variant; OpenBSD/i386 uses the _obsd variant; and Windows uses i386pe.
    for emu in elf_i386 elf_i386_fbsd elf_i386_obsd i386pe; do
        if "$ld" -verbose 2>&1 | grep -q "^[[:space:]]*$emu[[:space:]]*$"; then
            ld_i386_emulation="$emu"
            roms="optionrom"
            break
        fi
    done
fi

# Check that the C++ compiler exists and works with the C compiler.
# All the QEMU_CXXFLAGS are based on QEMU_CFLAGS. Keep this at the end to don't miss any other that could be added.
if has $cxx; then
    cat > $TMPC <<EOF
int c_function(void);
int main(void) { return c_function(); }
EOF

    compile_object

    cat > $TMPCXX <<EOF
extern "C" {
   int c_function(void);
}
int c_function(void) { return 42; }
EOF

    update_cxxflags

    if do_cxx $QEMU_CXXFLAGS -o $TMPE $TMPCXX $TMPO $LDFLAGS; then
        # C++ compiler $cxx works ok with C compiler $cc
        :
    else
        echo "C++ compiler $cxx does not work with C compiler $cc"
        echo "Disabling C++ specific optional code"
        cxx=
    fi
else
    echo "No C++ compiler available; disabling C++ specific optional code"
    cxx=
fi

echo_version() {
    if test "$1" = "yes" ; then
        echo "($2)"
    fi
}

# prepend pixman and ftd flags after all config tests are done
QEMU_CFLAGS="$pixman_cflags $fdt_cflags $QEMU_CFLAGS"
libs_softmmu="$pixman_libs $libs_softmmu"

echo "Install prefix    $prefix"
echo "BIOS directory    $(eval echo $qemu_datadir)"
echo "firmware path     $(eval echo $firmwarepath)"
echo "binary directory  $(eval echo $bindir)"
echo "library directory $(eval echo $libdir)"
echo "module directory  $(eval echo $qemu_moddir)"
echo "libexec directory $(eval echo $libexecdir)"
echo "include directory $(eval echo $includedir)"
echo "config directory  $(eval echo $sysconfdir)"
echo "local state directory   $(eval echo $local_statedir)"
echo "Manual directory  $(eval echo $mandir)"
echo "ELF interp prefix $interp_prefix"
echo "Source path       $source_path"
echo "GIT binary        $git"
echo "GIT submodules    $git_submodules"
echo "C compiler        $cc"
echo "Host C compiler   $host_cc"
echo "C++ compiler      $cxx"
echo "Objective-C compiler $objcc"
echo "ARFLAGS           $ARFLAGS"
echo "CFLAGS            $CFLAGS"
echo "QEMU_CFLAGS       $QEMU_CFLAGS"
echo "LDFLAGS           $LDFLAGS"
echo "make              $make"
echo "install           $install"
echo "python            $python"
if test "$slirp" = "yes" ; then
    echo "smbd              $smbd"
fi
echo "module support    $modules"
echo "host CPU          $cpu"
echo "host big endian   $bigendian"
echo "target list       $target_list"
echo "gprof enabled     $gprof"
echo "sparse enabled    $sparse"
echo "strip binaries    $strip_opt"
echo "profiler          $profiler"
echo "static build      $static"
echo "TLS priority      $tls_priority"
echo "libtasn1          $tasn1"
echo "virgl support     $virglrenderer"
echo "Block whitelist (rw) $block_drv_rw_whitelist"
echo "Block whitelist (ro) $block_drv_ro_whitelist"
echo "VirtFS support    $virtfs"
echo "Multipath support $mpath"
echo "PIE               $pie"
echo "vde support       $vde"
echo "netmap support    $netmap"
echo "Linux AIO support $linux_aio"
echo "ATTR/XATTR support $attr"
echo "Install blobs     $blobs"
echo "KVM support       $kvm"
echo "I440FX support    $piix"
echo "malloc trim support $malloc_trim"
echo "fdt support       $fdt"
echo "membarrier        $membarrier"
echo "preadv support    $preadv"
echo "fdatasync         $fdatasync"
echo "madvise           $madvise"
echo "posix_madvise     $posix_madvise"
echo "posix_memalign    $posix_memalign"
echo "libcap-ng support $cap_ng"
echo "vhost-net support $vhost_net"
echo "vhost-crypto support $vhost_crypto"
echo "vhost-scsi support $vhost_scsi"
echo "vhost-vsock support $vhost_vsock"
echo "vhost-user support $vhost_user"
echo "Trace backends    $trace_backends"
if have_backend "simple"; then
echo "Trace output file $trace_file-<pid>"
fi
echo "rbd support       $rbd"
echo "xfsctl support    $xfs"
echo "libiscsi support  $libiscsi"
echo "libnfs support    $libnfs"
echo "seccomp support   $seccomp"
echo "coroutine backend $coroutine"
echo "coroutine pool    $coroutine_pool"
echo "debug stack usage $debug_stack_usage"
echo "crypto afalg      $crypto_afalg"
echo "gcov              $gcov_tool"
echo "gcov enabled      $gcov"
echo "TPM support       $tpm"
echo "libssh2 support   $libssh2"
echo "TPM passthrough   $tpm_passthrough"
echo "TPM emulator      $tpm_emulator"
echo "QOM debugging     $qom_cast_debug"
echo "Live block migration $live_block_migration"
echo "lzo support       $lzo"
echo "snappy support    $snappy"
echo "NUMA host support $numa"
echo "tcmalloc support  $tcmalloc"
echo "jemalloc support  $jemalloc"
echo "avx2 optimization $avx2_opt"
echo "replication support $replication"

if test "$supported_cpu" = "no"; then
    echo
    echo "WARNING: SUPPORT FOR THIS HOST CPU WILL GO AWAY IN FUTURE RELEASES!"
    echo
    echo "CPU host architecture $cpu support is not currently maintained."
    echo "The QEMU project intends to remove support for this host CPU in"
    echo "a future release if nobody volunteers to maintain it and to"
    echo "provide a build host for our continuous integration setup."
    echo "configure has succeeded and you can continue to build, but"
    echo "if you care about QEMU on this platform you should contact"
    echo "us upstream at qemu-devel@nongnu.org."
fi

if test "$supported_os" = "no"; then
    echo
    echo "WARNING: SUPPORT FOR THIS HOST OS WILL GO AWAY IN FUTURE RELEASES!"
    echo
    echo "Host OS $targetos support is not currently maintained."
    echo "The QEMU project intends to remove support for this host OS in"
    echo "a future release if nobody volunteers to maintain it and to"
    echo "provide a build host for our continuous integration setup."
    echo "configure has succeeded and you can continue to build, but"
    echo "if you care about QEMU on this platform you should contact"
    echo "us upstream at qemu-devel@nongnu.org."
fi

config_host_mak="config-host.mak"

echo "# Automatically generated by configure - do not modify" > $config_host_mak
echo >> $config_host_mak

echo all: >> $config_host_mak
echo "prefix=$prefix" >> $config_host_mak
echo "bindir=$bindir" >> $config_host_mak
echo "libdir=$libdir" >> $config_host_mak
echo "libexecdir=$libexecdir" >> $config_host_mak
echo "includedir=$includedir" >> $config_host_mak
echo "mandir=$mandir" >> $config_host_mak
echo "sysconfdir=$sysconfdir" >> $config_host_mak
echo "qemu_confdir=$qemu_confdir" >> $config_host_mak
echo "qemu_datadir=$qemu_datadir" >> $config_host_mak
echo "qemu_firmwarepath=$firmwarepath" >> $config_host_mak
echo "qemu_docdir=$qemu_docdir" >> $config_host_mak
echo "qemu_moddir=$qemu_moddir" >> $config_host_mak
  echo "qemu_localstatedir=$local_statedir" >> $config_host_mak
echo "qemu_helperdir=$libexecdir" >> $config_host_mak
echo "qemu_localedir=$qemu_localedir" >> $config_host_mak
echo "libs_softmmu=$libs_softmmu" >> $config_host_mak
echo "GIT=$git" >> $config_host_mak
echo "GIT_SUBMODULES=$git_submodules" >> $config_host_mak
echo "GIT_UPDATE=$git_update" >> $config_host_mak

echo "ARCH=$ARCH" >> $config_host_mak

if test "$strip_opt" = "yes" ; then
  echo "STRIP=${strip}" >> $config_host_mak
fi
if test "$bigendian" = "yes" ; then
  echo "HOST_WORDS_BIGENDIAN=y" >> $config_host_mak
fi
echo "CONFIG_POSIX=y" >> $config_host_mak

if test "$linux" = "yes" ; then
  echo "CONFIG_LINUX=y" >> $config_host_mak
fi

if test "$static" = "yes" ; then
  echo "CONFIG_STATIC=y" >> $config_host_mak
fi
if test "$profiler" = "yes" ; then
  echo "CONFIG_PROFILER=y" >> $config_host_mak
fi
if test "$slirp" = "yes" ; then
  echo "CONFIG_SLIRP=y" >> $config_host_mak
  echo "CONFIG_SMBD_COMMAND=\"$smbd\"" >> $config_host_mak
fi
if test "$netmap" = "yes" ; then
  echo "CONFIG_NETMAP=y" >> $config_host_mak
fi
if test "$l2tpv3" = "yes" ; then
  echo "CONFIG_L2TPV3=y" >> $config_host_mak
fi
if test "$cap_ng" = "yes" ; then
  echo "CONFIG_LIBCAP=y" >> $config_host_mak
fi
echo "CONFIG_BDRV_RW_WHITELIST=$block_drv_rw_whitelist" >> $config_host_mak
echo "CONFIG_BDRV_RO_WHITELIST=$block_drv_ro_whitelist" >> $config_host_mak
if test "$xkbcommon" = "yes" ; then
  echo "XKBCOMMON_CFLAGS=$xkbcommon_cflags" >> $config_host_mak
  echo "XKBCOMMON_LIBS=$xkbcommon_libs" >> $config_host_mak
fi
if test "$fnmatch" = "yes" ; then
  echo "CONFIG_FNMATCH=y" >> $config_host_mak
fi
if test "$xfs" = "yes" ; then
  echo "CONFIG_XFS=y" >> $config_host_mak
fi
qemu_version=$(head $source_path/VERSION)
echo "VERSION=$qemu_version" >>$config_host_mak
echo "PKGVERSION=$pkgversion" >>$config_host_mak
echo "SRC_PATH=$source_path" >> $config_host_mak
echo "TARGET_DIRS=$target_list" >> $config_host_mak
if test "$modules" = "yes"; then
  # $shacmd can generate a hash started with digit, which the compiler doesn't
  # like as an symbol. So prefix it with an underscore
  echo "CONFIG_STAMP=_$( (echo $qemu_version; echo $pkgversion; cat $0) | $shacmd - | cut -f1 -d\ )" >> $config_host_mak
  echo "CONFIG_MODULES=y" >> $config_host_mak
fi
if test "$have_x11" = "yes" -a "$need_x11" = "yes"; then
  echo "CONFIG_X11=y" >> $config_host_mak
  echo "X11_CFLAGS=$x11_cflags" >> $config_host_mak
  echo "X11_LIBS=$x11_libs" >> $config_host_mak
fi
if test "$pipe2" = "yes" ; then
  echo "CONFIG_PIPE2=y" >> $config_host_mak
fi
if test "$accept4" = "yes" ; then
  echo "CONFIG_ACCEPT4=y" >> $config_host_mak
fi
if test "$splice" = "yes" ; then
  echo "CONFIG_SPLICE=y" >> $config_host_mak
fi
if test "$eventfd" = "yes" ; then
  echo "CONFIG_EVENTFD=y" >> $config_host_mak
fi
if test "$memfd" = "yes" ; then
  echo "CONFIG_MEMFD=y" >> $config_host_mak
fi
if test "$fallocate" = "yes" ; then
  echo "CONFIG_FALLOCATE=y" >> $config_host_mak
fi
if test "$fallocate_punch_hole" = "yes" ; then
  echo "CONFIG_FALLOCATE_PUNCH_HOLE=y" >> $config_host_mak
fi
if test "$fallocate_zero_range" = "yes" ; then
  echo "CONFIG_FALLOCATE_ZERO_RANGE=y" >> $config_host_mak
fi
if test "$posix_fallocate" = "yes" ; then
  echo "CONFIG_POSIX_FALLOCATE=y" >> $config_host_mak
fi
if test "$sync_file_range" = "yes" ; then
  echo "CONFIG_SYNC_FILE_RANGE=y" >> $config_host_mak
fi
if test "$fiemap" = "yes" ; then
  echo "CONFIG_FIEMAP=y" >> $config_host_mak
fi
if test "$dup3" = "yes" ; then
  echo "CONFIG_DUP3=y" >> $config_host_mak
fi
if test "$ppoll" = "yes" ; then
  echo "CONFIG_PPOLL=y" >> $config_host_mak
fi
if test "$prctl_pr_set_timerslack" = "yes" ; then
  echo "CONFIG_PRCTL_PR_SET_TIMERSLACK=y" >> $config_host_mak
fi
if test "$epoll" = "yes" ; then
  echo "CONFIG_EPOLL=y" >> $config_host_mak
fi
if test "$epoll_create1" = "yes" ; then
  echo "CONFIG_EPOLL_CREATE1=y" >> $config_host_mak
fi
if test "$sendfile" = "yes" ; then
  echo "CONFIG_SENDFILE=y" >> $config_host_mak
fi
if test "$timerfd" = "yes" ; then
  echo "CONFIG_TIMERFD=y" >> $config_host_mak
fi
if test "$setns" = "yes" ; then
  echo "CONFIG_SETNS=y" >> $config_host_mak
fi
if test "$clock_adjtime" = "yes" ; then
  echo "CONFIG_CLOCK_ADJTIME=y" >> $config_host_mak
fi
if test "$syncfs" = "yes" ; then
  echo "CONFIG_SYNCFS=y" >> $config_host_mak
fi
if test "$inotify" = "yes" ; then
  echo "CONFIG_INOTIFY=y" >> $config_host_mak
fi
if test "$inotify1" = "yes" ; then
  echo "CONFIG_INOTIFY1=y" >> $config_host_mak
fi
if test "$sem_timedwait" = "yes" ; then
  echo "CONFIG_SEM_TIMEDWAIT=y" >> $config_host_mak
fi
if test "$byteswap_h" = "yes" ; then
  echo "CONFIG_BYTESWAP_H=y" >> $config_host_mak
fi
if test "$bswap_h" = "yes" ; then
  echo "CONFIG_MACHINE_BSWAP_H=y" >> $config_host_mak
fi
if test "$glib_subprocess" = "yes" ; then
  echo "CONFIG_HAS_GLIB_SUBPROCESS_TESTS=y" >> $config_host_mak
fi
echo "CONFIG_TLS_PRIORITY=\"$tls_priority\"" >> $config_host_mak
if test "$tasn1" = "yes" ; then
  echo "CONFIG_TASN1=y" >> $config_host_mak
fi
if test "$have_ifaddrs_h" = "yes" ; then
    echo "HAVE_IFADDRS_H=y" >> $config_host_mak
fi
if test "$have_broken_size_max" = "yes" ; then
    echo "HAVE_BROKEN_SIZE_MAX=y" >> $config_host_mak
fi

# Work around a system header bug with some kernel/XFS header
# versions where they both try to define 'struct fsxattr':
# xfs headers will not try to redefine structs from linux headers
# if this macro is set.
if test "$have_fsxattr" = "yes" ; then
    echo "HAVE_FSXATTR=y" >> $config_host_mak
fi
if test "$virglrenderer" = "yes" ; then
  echo "CONFIG_VIRGL=y" >> $config_host_mak
  echo "VIRGL_CFLAGS=$virgl_cflags" >> $config_host_mak
  echo "VIRGL_LIBS=$virgl_libs" >> $config_host_mak
fi
if test "$linux_aio" = "yes" ; then
  echo "CONFIG_LINUX_AIO=y" >> $config_host_mak
fi
if test "$attr" = "yes" ; then
  echo "CONFIG_ATTR=y" >> $config_host_mak
fi
if test "$libattr" = "yes" ; then
  echo "CONFIG_LIBATTR=y" >> $config_host_mak
fi
if test "$virtfs" = "yes" ; then
  echo "CONFIG_VIRTFS=y" >> $config_host_mak
fi
if test "$mpath" = "yes" ; then
  echo "CONFIG_MPATH=y" >> $config_host_mak
fi
if test "$vhost_scsi" = "yes" ; then
  echo "CONFIG_VHOST_SCSI=y" >> $config_host_mak
fi
if test "$vhost_net" = "yes" -a "$vhost_user" = "yes"; then
  echo "CONFIG_VHOST_NET_USED=y" >> $config_host_mak
fi
if test "$vhost_crypto" = "yes" ; then
  echo "CONFIG_VHOST_CRYPTO=y" >> $config_host_mak
fi
if test "$vhost_vsock" = "yes" ; then
  echo "CONFIG_VHOST_VSOCK=y" >> $config_host_mak
fi
if test "$vhost_user" = "yes" ; then
  echo "CONFIG_VHOST_USER=y" >> $config_host_mak
fi
if test "$blobs" = "yes" ; then
  echo "INSTALL_BLOBS=yes" >> $config_host_mak
fi
if test "$iovec" = "yes" ; then
  echo "CONFIG_IOVEC=y" >> $config_host_mak
fi
if test "$preadv" = "yes" ; then
  echo "CONFIG_PREADV=y" >> $config_host_mak
fi
if test "$fdt" = "yes" ; then
  echo "CONFIG_FDT=y" >> $config_host_mak
fi
if test "$membarrier" = "yes" ; then
  echo "CONFIG_MEMBARRIER=y" >> $config_host_mak
fi
if test "$signalfd" = "yes" ; then
  echo "CONFIG_SIGNALFD=y" >> $config_host_mak
fi
if test "$fdatasync" = "yes" ; then
  echo "CONFIG_FDATASYNC=y" >> $config_host_mak
fi
if test "$madvise" = "yes" ; then
  echo "CONFIG_MADVISE=y" >> $config_host_mak
fi
if test "$posix_madvise" = "yes" ; then
  echo "CONFIG_POSIX_MADVISE=y" >> $config_host_mak
fi
if test "$posix_memalign" = "yes" ; then
  echo "CONFIG_POSIX_MEMALIGN=y" >> $config_host_mak
fi

if test "$malloc_trim" = "yes" ; then
  echo "CONFIG_MALLOC_TRIM=y" >> $config_host_mak
fi

if test "$avx2_opt" = "yes" ; then
  echo "CONFIG_AVX2_OPT=y" >> $config_host_mak
fi

if test "$lzo" = "yes" ; then
  echo "CONFIG_LZO=y" >> $config_host_mak
fi

if test "$snappy" = "yes" ; then
  echo "CONFIG_SNAPPY=y" >> $config_host_mak
fi

if test "$libiscsi" = "yes" ; then
  echo "CONFIG_LIBISCSI=m" >> $config_host_mak
  echo "LIBISCSI_CFLAGS=$libiscsi_cflags" >> $config_host_mak
  echo "LIBISCSI_LIBS=$libiscsi_libs" >> $config_host_mak
fi

if test "$libnfs" = "yes" ; then
  echo "CONFIG_LIBNFS=m" >> $config_host_mak
  echo "LIBNFS_LIBS=$libnfs_libs" >> $config_host_mak
fi

if test "$seccomp" = "yes"; then
  echo "CONFIG_SECCOMP=y" >> $config_host_mak
  echo "SECCOMP_CFLAGS=$seccomp_cflags" >> $config_host_mak
  echo "SECCOMP_LIBS=$seccomp_libs" >> $config_host_mak
fi

if test "$localtime_r" = "yes" ; then
  echo "CONFIG_LOCALTIME_R=y" >> $config_host_mak
fi
if test "$qom_cast_debug" = "yes" ; then
  echo "CONFIG_QOM_CAST_DEBUG=y" >> $config_host_mak
fi
if test "$rbd" = "yes" ; then
  echo "CONFIG_RBD=m" >> $config_host_mak
  echo "RBD_CFLAGS=$rbd_cflags" >> $config_host_mak
  echo "RBD_LIBS=$rbd_libs" >> $config_host_mak
fi

echo "CONFIG_COROUTINE_BACKEND=$coroutine" >> $config_host_mak
if test "$coroutine_pool" = "yes" ; then
  echo "CONFIG_COROUTINE_POOL=1" >> $config_host_mak
else
  echo "CONFIG_COROUTINE_POOL=0" >> $config_host_mak
fi

if test "$debug_stack_usage" = "yes" ; then
  echo "CONFIG_DEBUG_STACK_USAGE=y" >> $config_host_mak
fi

if test "$crypto_afalg" = "yes" ; then
  echo "CONFIG_AF_ALG=y" >> $config_host_mak
fi

if test "$open_by_handle_at" = "yes" ; then
  echo "CONFIG_OPEN_BY_HANDLE=y" >> $config_host_mak
fi

if test "$linux_magic_h" = "yes" ; then
  echo "CONFIG_LINUX_MAGIC_H=y" >> $config_host_mak
fi

if test "$pragma_diagnostic_available" = "yes" ; then
  echo "CONFIG_PRAGMA_DIAGNOSTIC_AVAILABLE=y" >> $config_host_mak
fi

if test "$valgrind_h" = "yes" ; then
  echo "CONFIG_VALGRIND_H=y" >> $config_host_mak
fi

if test "$have_asan_iface_fiber" = "yes" ; then
    echo "CONFIG_ASAN_IFACE_FIBER=y" >> $config_host_mak
fi

if test "$has_environ" = "yes" ; then
  echo "CONFIG_HAS_ENVIRON=y" >> $config_host_mak
fi

if test "$cpuid_h" = "yes" ; then
  echo "CONFIG_CPUID_H=y" >> $config_host_mak
fi

if test "$int128" = "yes" ; then
  echo "CONFIG_INT128=y" >> $config_host_mak
fi

if test "$atomic128" = "yes" ; then
  echo "CONFIG_ATOMIC128=y" >> $config_host_mak
fi

if test "$atomic64" = "yes" ; then
  echo "CONFIG_ATOMIC64=y" >> $config_host_mak
fi

if test "$vector16" = "yes" ; then
  echo "CONFIG_VECTOR16=y" >> $config_host_mak
fi

if test "$getauxval" = "yes" ; then
  echo "CONFIG_GETAUXVAL=y" >> $config_host_mak
fi

if test "$libssh2" = "yes" ; then
  echo "CONFIG_LIBSSH2=m" >> $config_host_mak
  echo "LIBSSH2_CFLAGS=$libssh2_cflags" >> $config_host_mak
  echo "LIBSSH2_LIBS=$libssh2_libs" >> $config_host_mak
fi

if test "$live_block_migration" = "yes" ; then
  echo "CONFIG_LIVE_BLOCK_MIGRATION=y" >> $config_host_mak
fi

if test "$tpm" = "yes"; then
  echo 'CONFIG_TPM=$(CONFIG_SOFTMMU)' >> $config_host_mak
  # TPM passthrough support?
  if test "$tpm_passthrough" = "yes"; then
    echo "CONFIG_TPM_PASSTHROUGH=y" >> $config_host_mak
  fi
  # TPM emulator support?
  if test "$tpm_emulator" = "yes"; then
    echo "CONFIG_TPM_EMULATOR=y" >> $config_host_mak
  fi
fi

echo "TRACE_BACKENDS=$trace_backends" >> $config_host_mak
if have_backend "nop"; then
  echo "CONFIG_TRACE_NOP=y" >> $config_host_mak
fi
if have_backend "simple"; then
  echo "CONFIG_TRACE_SIMPLE=y" >> $config_host_mak
  # Set the appropriate trace file.
  trace_file="\"$trace_file-\" FMT_pid"
fi
if have_backend "log"; then
  echo "CONFIG_TRACE_LOG=y" >> $config_host_mak
fi
if have_backend "ust"; then
  echo "CONFIG_TRACE_UST=y" >> $config_host_mak
fi
if have_backend "dtrace"; then
  echo "CONFIG_TRACE_DTRACE=y" >> $config_host_mak
  if test "$trace_backend_stap" = "yes" ; then
    echo "CONFIG_TRACE_SYSTEMTAP=y" >> $config_host_mak
  fi
fi
if have_backend "ftrace"; then
  if test "$linux" = "yes" ; then
    echo "CONFIG_TRACE_FTRACE=y" >> $config_host_mak
  else
    feature_not_found "ftrace(trace backend)" "ftrace requires Linux"
  fi
fi
if have_backend "syslog"; then
  if test "$posix_syslog" = "yes" ; then
    echo "CONFIG_TRACE_SYSLOG=y" >> $config_host_mak
  else
    feature_not_found "syslog(trace backend)" "syslog not available"
  fi
fi
echo "CONFIG_TRACE_FILE=$trace_file" >> $config_host_mak

if test "$have_rtnetlink" = "yes" ; then
  echo "CONFIG_RTNETLINK=y" >> $config_host_mak
fi

if test "$replication" = "yes" ; then
  echo "CONFIG_REPLICATION=y" >> $config_host_mak
fi

if test "$have_af_vsock" = "yes" ; then
  echo "CONFIG_AF_VSOCK=y" >> $config_host_mak
fi

if test "$have_sysmacros" = "yes" ; then
  echo "CONFIG_SYSMACROS=y" >> $config_host_mak
fi

if test "$have_static_assert" = "yes" ; then
  echo "CONFIG_STATIC_ASSERT=y" >> $config_host_mak
fi

if test "$have_utmpx" = "yes" ; then
  echo "HAVE_UTMPX=y" >> $config_host_mak
fi

if test "$ivshmem" = "yes" ; then
  echo "CONFIG_IVSHMEM=y" >> $config_host_mak
fi

# Hold two types of flag:
#   CONFIG_THREAD_SETNAME_BYTHREAD  - we've got a way of setting the name on
#                                     a thread we have a handle to
#   CONFIG_PTHREAD_SETNAME_NP       - A way of doing it on a particular
#                                     platform
if test "$pthread_setname_np" = "yes" ; then
  echo "CONFIG_THREAD_SETNAME_BYTHREAD=y" >> $config_host_mak
  echo "CONFIG_PTHREAD_SETNAME_NP=y" >> $config_host_mak
fi

if test "$ARCH" = "x86_64" ; then
  QEMU_INCLUDES="-iquote \$(SRC_PATH)/tcg/i386 $QEMU_INCLUDES"
else
  QEMU_INCLUDES="-iquote \$(SRC_PATH)/tcg/\$(ARCH) $QEMU_INCLUDES"
fi
QEMU_INCLUDES="-iquote \$(SRC_PATH)/tcg $QEMU_INCLUDES"

echo "TOOLS=$tools" >> $config_host_mak
echo "ROMS=$roms" >> $config_host_mak
echo "MAKE=$make" >> $config_host_mak
echo "INSTALL=$install" >> $config_host_mak
echo "INSTALL_DIR=$install -d -m 0755" >> $config_host_mak
echo "INSTALL_DATA=$install -c -m 0644" >> $config_host_mak
echo "INSTALL_PROG=$install -c -m 0755" >> $config_host_mak
echo "INSTALL_LIB=$install -c -m 0644" >> $config_host_mak
echo "PYTHON=$python" >> $config_host_mak
echo "CC=$cc" >> $config_host_mak
if $iasl -h > /dev/null 2>&1; then
  echo "IASL=$iasl" >> $config_host_mak
fi
echo "CC_I386=$cc_i386" >> $config_host_mak
echo "HOST_CC=$host_cc" >> $config_host_mak
echo "CXX=$cxx" >> $config_host_mak
echo "OBJCC=$objcc" >> $config_host_mak
echo "AR=$ar" >> $config_host_mak
echo "ARFLAGS=$ARFLAGS" >> $config_host_mak
echo "AS=$as" >> $config_host_mak
echo "CCAS=$ccas" >> $config_host_mak
echo "CPP=$cpp" >> $config_host_mak
echo "OBJCOPY=$objcopy" >> $config_host_mak
echo "LD=$ld" >> $config_host_mak
echo "RANLIB=$ranlib" >> $config_host_mak
echo "NM=$nm" >> $config_host_mak
echo "WINDRES=$windres" >> $config_host_mak
echo "CFLAGS=$CFLAGS" >> $config_host_mak
echo "CFLAGS_NOPIE=$CFLAGS_NOPIE" >> $config_host_mak
echo "QEMU_CFLAGS=$QEMU_CFLAGS" >> $config_host_mak
echo "QEMU_CXXFLAGS=$QEMU_CXXFLAGS" >> $config_host_mak
echo "QEMU_INCLUDES=$QEMU_INCLUDES" >> $config_host_mak
if test "$sparse" = "yes" ; then
  echo "CC           := REAL_CC=\"\$(CC)\" cgcc"       >> $config_host_mak
  echo "CPP          := REAL_CC=\"\$(CPP)\" cgcc"      >> $config_host_mak
  echo "CXX          := REAL_CC=\"\$(CXX)\" cgcc"      >> $config_host_mak
  echo "HOST_CC      := REAL_CC=\"\$(HOST_CC)\" cgcc"  >> $config_host_mak
  echo "QEMU_CFLAGS  += -Wbitwise -Wno-transparent-union -Wno-old-initializer -Wno-non-pointer-null" >> $config_host_mak
fi
if test "$cross_prefix" != ""; then
  echo "AUTOCONF_HOST := --host=${cross_prefix%-}"     >> $config_host_mak
else
  echo "AUTOCONF_HOST := "                             >> $config_host_mak
fi
echo "LDFLAGS=$LDFLAGS" >> $config_host_mak
echo "LDFLAGS_NOPIE=$LDFLAGS_NOPIE" >> $config_host_mak
echo "LD_REL_FLAGS=$LD_REL_FLAGS" >> $config_host_mak
echo "LD_I386_EMULATION=$ld_i386_emulation" >> $config_host_mak
echo "LIBS+=$LIBS" >> $config_host_mak
echo "LIBS_TOOLS+=$libs_tools" >> $config_host_mak
echo "PTHREAD_LIB=$PTHREAD_LIB" >> $config_host_mak
echo "EXESUF=$EXESUF" >> $config_host_mak
echo "DSOSUF=$DSOSUF" >> $config_host_mak
echo "LDFLAGS_SHARED=$LDFLAGS_SHARED" >> $config_host_mak
echo "LIBS_QGA+=$libs_qga" >> $config_host_mak
echo "TASN1_LIBS=$tasn1_libs" >> $config_host_mak
echo "TASN1_CFLAGS=$tasn1_cflags" >> $config_host_mak
echo "POD2MAN=$POD2MAN" >> $config_host_mak
echo "TRANSLATE_OPT_CFLAGS=$TRANSLATE_OPT_CFLAGS" >> $config_host_mak
if test "$gcov" = "yes" ; then
  echo "CONFIG_GCOV=y" >> $config_host_mak
  echo "GCOV=$gcov_tool" >> $config_host_mak
fi

# use included Linux headers
if test "$linux" = "yes" ; then
  mkdir -p linux-headers
  case "$cpu" in
  x86_64)
    linux_arch=x86
    ;;
  aarch64)
    linux_arch=arm64
    ;;
  *)
    # For most CPUs the kernel architecture name and QEMU CPU name match.
    linux_arch="$cpu"
    ;;
  esac
    # For non-KVM architectures we will not have asm headers
    if [ -e "$source_path/linux-headers/asm-$linux_arch" ]; then
      symlink "$source_path/linux-headers/asm-$linux_arch" linux-headers/asm
    fi
fi

for target in $target_list; do
target_dir="$target"
config_target_mak=$target_dir/config-target.mak
target_name=$(echo $target | cut -d '-' -f 1)
target_bigendian="no"

target_softmmu="no"
case "$target" in
  ${target_name}-softmmu)
    target_softmmu="yes"
    ;;
  *)
    error_exit "Target '$target' not recognised"
    exit 1
    ;;
esac

mkdir -p $target_dir
echo "# Automatically generated by configure - do not modify" > $config_target_mak

bflt="no"
interp_prefix1=$(echo "$interp_prefix" | sed "s/%M/$target_name/g")
gdb_xml_files=""

TARGET_ARCH="$target_name"
TARGET_BASE_ARCH=""
TARGET_ABI_DIR=""

case "$target_name" in
  x86_64)
    TARGET_BASE_ARCH=i386
    gdb_xml_files="i386-64bit.xml i386-64bit-core.xml i386-64bit-sse.xml"
  ;;
  aarch64)
    TARGET_ARCH=aarch64
    TARGET_BASE_ARCH=arm
    bflt="yes"
    gdb_xml_files="aarch64-core.xml aarch64-fpu.xml arm-core.xml arm-vfp.xml arm-vfp3.xml arm-neon.xml"
  ;;
  *)
    error_exit "Unsupported target CPU"
  ;;
esac
# TARGET_BASE_ARCH needs to be defined after TARGET_ARCH
if [ "$TARGET_BASE_ARCH" = "" ]; then
  TARGET_BASE_ARCH=$TARGET_ARCH
fi

symlink "$source_path/Makefile.target" "$target_dir/Makefile"

upper() {
    echo "$@"| LC_ALL=C tr '[a-z]' '[A-Z]'
}

target_arch_name="$(upper $TARGET_ARCH)"
echo "TARGET_$target_arch_name=y" >> $config_target_mak
echo "TARGET_NAME=$target_name" >> $config_target_mak
echo "TARGET_BASE_ARCH=$TARGET_BASE_ARCH" >> $config_target_mak
if [ "$TARGET_ABI_DIR" = "" ]; then
  TARGET_ABI_DIR=$TARGET_ARCH
fi
echo "TARGET_ABI_DIR=$TARGET_ABI_DIR" >> $config_target_mak
if [ "$HOST_VARIANT_DIR" != "" ]; then
    echo "HOST_VARIANT_DIR=$HOST_VARIANT_DIR" >> $config_target_mak
fi

if supported_kvm_target $target; then
    echo "CONFIG_KVM=y" >> $config_target_mak
    if test "$vhost_net" = "yes" ; then
        echo "CONFIG_VHOST_NET=y" >> $config_target_mak
        if test "$vhost_user" = "yes" ; then
            echo "CONFIG_VHOST_USER_NET_TEST_$target_name=y" >> $config_host_mak
        fi
    fi
    if test "$piix" = "yes" && test "$target_name" = "x86_64"; then
        echo "CONFIG_PIIX=y" >> $config_host_mak
    fi
fi
if test "$target_bigendian" = "yes" ; then
  echo "TARGET_WORDS_BIGENDIAN=y" >> $config_target_mak
fi
if test "$target_softmmu" = "yes" ; then
  echo "CONFIG_SOFTMMU=y" >> $config_target_mak
fi
list=""
if test ! -z "$gdb_xml_files" ; then
  for x in $gdb_xml_files; do
    list="$list $source_path/gdb-xml/$x"
  done
  echo "TARGET_XML_FILES=$list" >> $config_target_mak
fi

# generate QEMU_CFLAGS/LDFLAGS for targets

cflags=""
ldflags=""

if test "$gprof" = "yes" ; then
  echo "TARGET_GPROF=yes" >> $config_target_mak
  if test "$target_softmmu" = "yes" ; then
    ldflags="-p $ldflags"
    echo "GPROF_CFLAGS=-p" >> $config_target_mak
  fi
fi

echo "LDFLAGS+=$ldflags" >> $config_target_mak
echo "QEMU_CFLAGS+=$cflags" >> $config_target_mak

done # for target in $targets

if [ "$dtc_internal" = "yes" ]; then
  echo "config-host.h: subdir-dtc" >> $config_host_mak
fi

if test "$numa" = "yes"; then
  echo "CONFIG_NUMA=y" >> $config_host_mak
fi

if test "$ccache_cpp2" = "yes"; then
  echo "export CCACHE_CPP2=y" >> $config_host_mak
fi

# build tree in object directory in case the source is not in the current directory
DIRS="tests tests/libqos tests/qapi-schema tests/qemu-iotests tests/vm"
DIRS="$DIRS docs docs/interop fsdev scsi"
DIRS="$DIRS roms/seabios"
FILES="Makefile qdict-test-data.txt"
FILES="$FILES po/Makefile"
FILES="$FILES pc-bios/optionrom/Makefile pc-bios/keymaps"
FILES="$FILES roms/seabios/Makefile"
FILES="$FILES pc-bios/qemu-icon.bmp"
FILES="$FILES .gdbinit scripts" # scripts needed by relative path in .gdbinit
for bios_file in \
    $source_path/pc-bios/*.bin \
    $source_path/pc-bios/*.lid \
    $source_path/pc-bios/*.aml \
    $source_path/pc-bios/*.rom \
    $source_path/pc-bios/*.dtb \
    $source_path/pc-bios/*.img \
    $source_path/pc-bios/openbios-* \
    $source_path/pc-bios/u-boot.* \
    $source_path/pc-bios/palcode-*
do
    FILES="$FILES pc-bios/$(basename $bios_file)"
done
for test_file in $(find $source_path/tests/acpi-test-data -type f)
do
    FILES="$FILES tests/acpi-test-data$(echo $test_file | sed -e 's/.*acpi-test-data//')"
done
mkdir -p $DIRS
for f in $FILES ; do
    if [ -e "$source_path/$f" ] && [ "$pwd_is_source_path" != "y" ]; then
        symlink "$source_path/$f" "$f"
    fi
done

# temporary config to build submodules
config_mak=roms/seabios/config.mak
echo "# Automatically generated by configure - do not modify" > $config_mak
echo "SRC_PATH=$source_path/roms/$rom" >> $config_mak
echo "AS=$as" >> $config_mak
echo "CCAS=$ccas" >> $config_mak
echo "CC=$cc" >> $config_mak
echo "BCC=bcc" >> $config_mak
echo "CPP=$cpp" >> $config_mak
echo "OBJCOPY=objcopy" >> $config_mak
echo "IASL=$iasl" >> $config_mak
echo "LD=$ld" >> $config_mak
echo "RANLIB=$ranlib" >> $config_mak


# set up tests data directory
if [ ! -e tests/data ]; then
    symlink "$source_path/tests/data" tests/data
fi

# set up qemu-iotests in this build directory
iotests_common_env="tests/qemu-iotests/common.env"
iotests_check="tests/qemu-iotests/check"

echo "# Automatically generated by configure - do not modify" > "$iotests_common_env"
echo >> "$iotests_common_env"
echo "export PYTHON='$python'" >> "$iotests_common_env"

if [ ! -e "$iotests_check" ]; then
    symlink "$source_path/$iotests_check" "$iotests_check"
fi

# Save the configure command line for later reuse.
cat <<EOD >config.status
#!/bin/sh
# Generated by configure.
# Run this file to recreate the current configuration.
# Compiler output produced by configure, useful for debugging
# configure, is in config.log if it exists.
EOD
printf "exec" >>config.status
printf " '%s'" "$0" "$@" >>config.status
echo ' "$@"' >>config.status
chmod +x config.status

rm -r "$TMPDIR1"
